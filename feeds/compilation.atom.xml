<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Pythran stories - compilation</title><link href="http://serge-sans-paille.github.io/pythran-stories/" rel="alternate"></link><link href="http://serge-sans-paille.github.io/pythran-stories/feeds/compilation.atom.xml" rel="self"></link><id>http://serge-sans-paille.github.io/pythran-stories/</id><updated>2020-04-23T00:00:00+02:00</updated><entry><title>Basic Value Range Analysis</title><link href="http://serge-sans-paille.github.io/pythran-stories/basic-value-range-analysis.html" rel="alternate"></link><published>2020-04-23T00:00:00+02:00</published><updated>2020-04-23T00:00:00+02:00</updated><author><name>serge-sans-paille</name></author><id>tag:serge-sans-paille.github.io,2020-04-23:/pythran-stories/basic-value-range-analysis.html</id><summary type="html">&lt;p class="first last"&gt;Pythran recently gained a significant improvment in its value range
analysis. Let's discuss some implementation details through a bunch of
examples.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Not every story begins with an issue, but this one does. And with a quite old
one! &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1059"&gt;#1059&lt;/a&gt; dates
back to October, 2018 :-) At that time, I was trying to efficiently compile some
kernels for a &lt;a class="reference external" href="https://github.com/scikit-image/scikit-image/pull/3226"&gt;scikit-image PR&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="integ-function-from-scikit-image"&gt;
&lt;h2&gt;&lt;tt class="docutils literal"&gt;_integ&lt;/tt&gt; function from scikit-image&lt;/h2&gt;
&lt;p&gt;This is the body of the &lt;tt class="docutils literal"&gt;_integ&lt;/tt&gt; function, from the &lt;tt class="docutils literal"&gt;_hessian_det_appx.pyx&lt;/tt&gt;
file in &lt;a class="reference external" href="https://scikit-image.org/"&gt;scikit-image&lt;/a&gt;. The original body is
written in &lt;a class="reference external" href="https://cython.org/"&gt;cython&lt;/a&gt;, with a few annotations:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;# cython: wraparound=False&lt;/span&gt;

&lt;span class="k"&gt;cdef&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="nf"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;nogil&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;


&lt;span class="k"&gt;cdef&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;cnp&lt;/span&gt;.&lt;span class="kt"&gt;double_t&lt;/span&gt; &lt;span class="nf"&gt;_integ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cnp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;double_t&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;rl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;Py_ssize_t&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;nogil&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

    &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;r2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;rl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mf"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;cdef&lt;/span&gt; &lt;span class="kt"&gt;cnp&lt;/span&gt;.&lt;span class="kt"&gt;double_t&lt;/span&gt; &lt;span class="nf"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mf"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ans&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The translation to python, and thus to pythran, would be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#pythran export _integ(float64[::], int, int, int, int)&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_integ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;r2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;rl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;c2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_clip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ans&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Very little changes here: the type annotations disappear, as Pythran infers them
from the top-level function and its &lt;tt class="docutils literal"&gt;pythran export&lt;/tt&gt; line. All Pythran
functions are &lt;tt class="docutils literal"&gt;nogil&lt;/tt&gt; by default (this is a strong requirement).&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;wraparound=False&lt;/tt&gt; comment also get removed, and an assert got added.
That's the core of this post: range value analysis and its use to detect
wraparound.
Basically, Pythran supports wraparound by default to match Python's indexing
behavior. But to avoid the test cost, it also tries hard to compute the possible
value range for each expression in the AST.&lt;/p&gt;
&lt;p&gt;In the case of &lt;tt class="docutils literal"&gt;_integ&lt;/tt&gt;, it would be great if Pythran could prove that, once
clipped, &lt;tt class="docutils literal"&gt;r&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;c&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;r2&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;c2&lt;/tt&gt; are all positive, that way no check
would be needed. However, to know that, we need to know that &lt;tt class="docutils literal"&gt;low &amp;gt;= 0&lt;/tt&gt;. This
property always hold at the call site, but doing a call-site specific analysis
would be too much, so a gentle &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; is helpful here.&lt;/p&gt;
&lt;p&gt;Note that it's still valid Python, and Pythran can enable or disable asserts
using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-DNDEBUG&lt;/span&gt;&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-UNDEBUG&lt;/span&gt;&lt;/tt&gt;, so there's no extra cost for an assert.&lt;/p&gt;
&lt;p&gt;Thanks to the assert, and to &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/pull/1522"&gt;PR #1522&lt;/a&gt; Pythran can compute
that &lt;tt class="docutils literal"&gt;_clip&lt;/tt&gt; always returns a positive value, thus deducing that no wraparound
is involved. Note that each indexing expression is handled independently, unlike
the global &lt;tt class="docutils literal"&gt;wraparound=False&lt;/tt&gt; decorator.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="basic-implementation"&gt;
&lt;h2&gt;Basic Implementation&lt;/h2&gt;
&lt;p&gt;Pythran range analysis is relatively simple: it does not support symbolic bounds
and only manipulates intervals. It is interprocedural given it computes the
range of the output, but without any assumption on the range of the arguments,
and the interprocedural analysis is not recursive. It has some built-in knowledge
about the value range of functions like &lt;tt class="docutils literal"&gt;len&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;range&lt;/tt&gt;, which proves to
be useful for practical cases.&lt;/p&gt;
&lt;p&gt;Let's illustrate that analysis through an example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;wtf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;wtf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ok&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's a control flow analysis, so it follows the control flow starting from the
function entry point. It first meets an &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt;, so we register that &lt;tt class="docutils literal"&gt;1 &amp;lt;= a &amp;lt;= inf&lt;/tt&gt;
(remember, we only use intervals). Then, there's an assignment of constant
value, so we have:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
1 &amp;lt;= a &amp;lt;= inf
10 &amp;lt;= b &amp;lt;= 10
10 &amp;lt;= c &amp;lt;= 10``
&lt;/pre&gt;
&lt;p&gt;Then comes a &lt;tt class="docutils literal"&gt;while&lt;/tt&gt; statement. A while usually has two successors: its body,
and the next statement. In that case we evaluate the condition and see that
it always holds, because we have &lt;tt class="docutils literal"&gt;1 &amp;lt;= a&lt;/tt&gt;, so we first perform a first round
of the body, getting, through the two accumulation (let's drop &lt;tt class="docutils literal"&gt;c&lt;/tt&gt; for the
sake of clarity):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
0 &amp;lt;= a &amp;lt;= inf
11 &amp;lt;= b &amp;lt;=11
&lt;/pre&gt;
&lt;p&gt;Then we're back to the test. The condition no longer always hold, so we need to
make a decision! The idea here is to perform a &lt;em&gt;widening&lt;/em&gt;, so we record current
state, and perform another round, getting &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-1&lt;/span&gt; &amp;lt;= a &amp;lt;= inf; 12 &amp;lt;= b &amp;lt;= 12&lt;/tt&gt;.
Through the comparison of the two states, we can see the evolution of &lt;tt class="docutils literal"&gt;a&lt;/tt&gt;
(it shrinks towards &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-inf&lt;/span&gt;&lt;/tt&gt;) and &lt;tt class="docutils literal"&gt;b&lt;/tt&gt; (it grows toward &lt;tt class="docutils literal"&gt;+inf&lt;/tt&gt;).
This maybe not super accurate, but it's a correct overestimate.
So we decide that right before the test, we have:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
-inf &amp;lt;= a &amp;lt;= inf
11 &amp;lt;= b &amp;lt;= inf
&lt;/pre&gt;
&lt;p&gt;It's safe to apply the condition at the entry point too, so let's constrain our
intervals once more to get the constraints in the body:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
1 &amp;lt;= a &amp;lt;= inf
11 &amp;lt;= b &amp;lt;= inf
&lt;/pre&gt;
&lt;p&gt;We're back to the successors of the &lt;tt class="docutils literal"&gt;while&lt;/tt&gt;. It's an &lt;tt class="docutils literal"&gt;if&lt;/tt&gt;! Let's first check
that the condition may hold… And it doesn't! Let's skip it then, and go further.
The next if is also never reached, so it's a skip again, and the final if may be
true (but we're not sure if it always is, remember that the intervals are an
over-estimation). So we need to visit both the true branch and the false branch
(i.e., in our case, the next statement). And merge the results.&lt;/p&gt;
&lt;p&gt;As it turns out, there's no change in the if body, and the return statement only
consumes the equations without modifying them.&lt;/p&gt;
&lt;p&gt;Running this code through &lt;tt class="docutils literal"&gt;pythran &lt;span class="pre"&gt;-P&lt;/span&gt;&lt;/tt&gt;, which optimizes the code
then prints the python code back, gives:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;a_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;a_&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;builtins&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;ok&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The two first prints have been removed, because they were guarded by conditions
that never hold.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="programming-nits"&gt;
&lt;h2&gt;Programming Nits&lt;/h2&gt;
&lt;p&gt;Using a naive control-flow based approach has some advantages. For instance, in the
following code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because the analysis explores the control flow graph in a depth-first manner,
when visiting the children of &lt;tt class="docutils literal"&gt;if a &amp;gt; 12&lt;/tt&gt;, it finds &lt;tt class="docutils literal"&gt;if a &amp;gt; 1&lt;/tt&gt; and knows
&lt;em&gt;for sure&lt;/em&gt; that the condition holds, thus ending up with &lt;tt class="docutils literal"&gt;b == 2&lt;/tt&gt; upon the
return. Then when visiting the &lt;tt class="docutils literal"&gt;else&lt;/tt&gt; branch, it records &lt;tt class="docutils literal"&gt;b == 2&lt;/tt&gt; and also
ends up with &lt;tt class="docutils literal"&gt;b == 2&lt;/tt&gt; upon the return.&lt;/p&gt;
&lt;p&gt;In the end, &lt;tt class="docutils literal"&gt;pythran &lt;span class="pre"&gt;-P&lt;/span&gt;&lt;/tt&gt; on the above snippets yields:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's be honest, this algorithm is super greedy, and if we find a sequence of &lt;tt class="docutils literal"&gt;if&lt;/tt&gt;
statements, it has an exponential complexity (and this happens a soon as we
unroll a loop with a condition in its body). In that case (4 threaded ifs, as of now) we fall back to a
less accurate but faster algorithm, that performs a tree transversal instead of
a control-flow graph transversal. This approach performs an union of the states after each if,
which leads to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-inf&lt;/span&gt; &amp;lt;= a &amp;lt;= inf; 1 &amp;lt;= b &amp;lt;= 2&lt;/tt&gt; after the first &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; in the
example above.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Use &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; statements! Pythran can extract precious information from them,
and there's no runtime cost unless you ask so ;-)&lt;/p&gt;
&lt;/div&gt;
</content><category term="compilation"></category></entry><entry><title>Gast, Beniget! Use-Def chains for Python Programs</title><link href="http://serge-sans-paille.github.io/pythran-stories/gast-beniget-use-def-chains-for-python-programs.html" rel="alternate"></link><published>2019-03-18T00:00:00+01:00</published><updated>2019-03-18T00:00:00+01:00</updated><author><name>serge-sans-paille</name></author><id>tag:serge-sans-paille.github.io,2019-03-18:/pythran-stories/gast-beniget-use-def-chains-for-python-programs.html</id><summary type="html">&lt;p class="first last"&gt;Many tools manipulate the Python AST to analyse or transform it.
Let's propose a collection of analyse those tools can leverage on: &lt;strong&gt;beniget&lt;/strong&gt;.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;In spite of its dynamic nature, the Python language has been granted a rich
ecosystem of Abstract Syntax Tree(AST) analysis and transformations. Off the top of my head, I can already cite:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/PyCQA/pyflakes"&gt;Pyflake&lt;/a&gt;, a Python linter;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.pylint.org/"&gt;Pylint&lt;/a&gt;, a Python linter and more;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pytorch.org/docs/stable/jit.html"&gt;TorchScript&lt;/a&gt;, a DSL embedded into Python for &lt;a class="reference external" href="https://pytorch.org/"&gt;PyTorch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.tensorflow.org/guide/autograph"&gt;autograph&lt;/a&gt; another DSL embedded into Python, for &lt;a class="reference external" href="https://www.tensorflow.org/"&gt;Tensorflow&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran"&gt;Pythran&lt;/a&gt; (of course!);&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0511/"&gt;PEP-511&lt;/a&gt; even proposed to normalize an API for code transformers-it got rejected.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And there probably are plenty of other users of the &lt;a class="reference external" href="https://docs.python.org/3/library/ast.html"&gt;ast&lt;/a&gt; module from the Python standard
library.&lt;/p&gt;
&lt;div class="section" id="foreword"&gt;
&lt;h2&gt;Foreword&lt;/h2&gt;
&lt;p&gt;If you're using the &lt;tt class="docutils literal"&gt;ast&lt;/tt&gt; module, then you should consider using the great
(&lt;em&gt;and home-backed&lt;/em&gt;) &lt;a class="reference external" href="https://github.com/serge-sans-paille/gast"&gt;gast&lt;/a&gt; package.
It offers a common tree structure to deal with the different Python version and
their changes. In other words, if you can transform or analyze &lt;tt class="docutils literal"&gt;gast&lt;/tt&gt; AST,
then you can handle most Python versions.&lt;/p&gt;
&lt;p&gt;Not convinced? It's already used by &lt;a class="reference external" href="https://www.tensorflow.org/"&gt;Tensorflow&lt;/a&gt;
and &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran"&gt;Pythran&lt;/a&gt;. And &lt;a class="reference external" href="https://github.com/serge-sans-paille/beniget"&gt;Beniget&lt;/a&gt; :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="about-use-def-chains"&gt;
&lt;h2&gt;About Use-Def Chains&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Use-define_chain"&gt;Use-def chains&lt;/a&gt; is a very
common compiler abstraction. It makes it possible to link any use of an
identifier to its definition, enabling many code optimisations like &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Constant_folding"&gt;constant
folding&lt;/a&gt; or &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Dead_code_elimination"&gt;dead code
elimination&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The following statements are annotated with &lt;tt class="docutils literal"&gt;DEF&lt;/tt&gt; (resp. &lt;tt class="docutils literal"&gt;USE&lt;/tt&gt;) to mark that the annotated statement defines (resp. uses) the associated identifier.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="c1"&gt;# DEF(a)&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;       &lt;span class="c1"&gt;# DEF(b) USE(a)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;# USE(a, b)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;           &lt;span class="c1"&gt;# USE(c)&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;12&amp;quot;&lt;/span&gt;    &lt;span class="c1"&gt;# DEF(a&amp;#39;)&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;      &lt;span class="c1"&gt;# DEF(a&amp;#39;&amp;#39;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;# USE(a&amp;#39;, a&amp;#39;&amp;#39;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From these annotations, using a data-flow analysis, one can build the def-use chains as:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
DEF(a) -&amp;gt; USE(a) # a + 2
       -&amp;gt; USE(a) # print(a, b)

DEF(b) -&amp;gt; USE(b) # print(a, b)

DEF(a') -&amp;gt; USE(a') # print(a)

DEF(a'') -&amp;gt; USE(a'') # print(a)
&lt;/pre&gt;
&lt;p&gt;There is no &lt;tt class="docutils literal"&gt;DEF&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;USE(c)&lt;/tt&gt; which means a probable &lt;tt class="docutils literal"&gt;NameError&lt;/tt&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-use-def-chains-from-beniget"&gt;
&lt;h2&gt;Using Use-Def Chains from Beniget&lt;/h2&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/serge-sans-paille/beniget/blob/master/README.rst"&gt;README&lt;/a&gt; from &lt;tt class="docutils literal"&gt;beniget&lt;/tt&gt; provides several use cases, from simple to complex ones. Let's go through some of them!&lt;/p&gt;
&lt;div class="section" id="detect-unused-imports"&gt;
&lt;h3&gt;Detect Unused Imports&lt;/h3&gt;
&lt;p&gt;This is a very basic usage: look for &lt;tt class="docutils literal"&gt;DEF&lt;/tt&gt; without any &lt;tt class="docutils literal"&gt;USE&lt;/tt&gt;, and warn about them, focusing on imported values.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;beniget&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;gast&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;ast&lt;/span&gt;

&lt;span class="c1"&gt;# parse some simple statements&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;from math import cos, sin; print(cos(3))&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# compute the def-use chains at module level&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;duc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;beniget&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DefUseChains&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;duc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;visit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# grab the import statement&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;imported&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;names&lt;/span&gt;

&lt;span class="c1"&gt;# inspect the users of each imported name&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;imported&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;   &lt;span class="n"&gt;ud&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;duc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;chains&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;ud&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Unused import: &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ud&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;span class="n"&gt;Unused&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At that point, the astute reader has already noted that due to the dynamic
nature of Python, one can fool this analysis by calling the &lt;tt class="docutils literal"&gt;eval&lt;/tt&gt; function,
eventually through an indirection, or by performing a lookup into
&lt;tt class="docutils literal"&gt;globals()&lt;/tt&gt;. More about this later.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="compute-a-function-s-closure"&gt;
&lt;h3&gt;Compute a Function's Closure&lt;/h3&gt;
&lt;p&gt;In Python, inner functions (and lambdas) can capture identifiers defined in the
outer scope. This analysis computes such identifiers by registering all &lt;tt class="docutils literal"&gt;USE&lt;/tt&gt;
from a local &lt;tt class="docutils literal"&gt;DEF&lt;/tt&gt;, then walking through all identifier and checking whether
they're one of the &lt;tt class="docutils literal"&gt;USE&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;An alternative approach would be to rely on the use-def chains to inspect all
the &lt;tt class="docutils literal"&gt;DEF&lt;/tt&gt;  of each &lt;tt class="docutils literal"&gt;USE&lt;/tt&gt; and ensure the &lt;tt class="docutils literal"&gt;DEF&lt;/tt&gt; come from the visited
function.&lt;/p&gt;
&lt;pre class="doctest-block"&gt;
&amp;gt;&amp;gt;&amp;gt; import gast as ast
&amp;gt;&amp;gt;&amp;gt; import beniget
&amp;gt;&amp;gt;&amp;gt; class Capture(ast.NodeVisitor):
...
...     def __init__(self, module_node):
...         # initialize def-use chains
...         self.chains = beniget.DefUseChains()
...         self.chains.visit(module_node)
...         self.users = set()  # users of local definitions
...         self.captured = set()  # identifiers that don't belong to local users
...
...     def visit_FunctionDef(self, node):
...         # initialize the set of node using a local variable
...         for def_ in self.chains.locals[node]:
...             self.users.update(use.node for use in def_.users())
...         self.generic_visit(node)
...
...     def visit_Name(self, node):
...         # register load of identifiers not locally defined
...         if isinstance(node.ctx, ast.Load):
...             if node not in self.users:
...                 self.captured.add(node.id)
&lt;/pre&gt;
&lt;pre class="doctest-block"&gt;
&amp;gt;&amp;gt;&amp;gt; code = 'def foo(x):\n def bar(): return x\n return bar'
&amp;gt;&amp;gt;&amp;gt; module = ast.parse(code)
&amp;gt;&amp;gt;&amp;gt; inner_function = module.body[0].body[0]
&amp;gt;&amp;gt;&amp;gt; capture = Capture(module)
&amp;gt;&amp;gt;&amp;gt; capture.visit(inner_function)
&amp;gt;&amp;gt;&amp;gt; list(capture.captured)
['x']
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="detecting-nameerror"&gt;
&lt;h3&gt;Detecting &lt;tt class="docutils literal"&gt;NameError&lt;/tt&gt;&lt;/h3&gt;
&lt;p&gt;Any &lt;tt class="docutils literal"&gt;USE&lt;/tt&gt; without &lt;tt class="docutils literal"&gt;DEF&lt;/tt&gt; is probably (and no, not &lt;strong&gt;certainly&lt;/strong&gt;) an error. But even if there's an associated &lt;tt class="docutils literal"&gt;DEF&lt;/tt&gt;, it could be an error; Consider the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There's a chance that &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; is unbound while executing &lt;tt class="docutils literal"&gt;print(a)&lt;/tt&gt;. It would be possible to combine &lt;tt class="docutils literal"&gt;beniget&lt;/tt&gt; with a dummy code transformation to detect this issue by generating dummy top-level definitions and checking if they have any &lt;tt class="docutils literal"&gt;USE&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;  &lt;span class="c1"&gt;# if any of those have a USE, then we have a potential issue&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="limitations"&gt;
&lt;h3&gt;Limitations&lt;/h3&gt;
&lt;p&gt;It's Python. So introspection and lazy binding are a pain for &lt;em&gt;any&lt;/em&gt; static analysis tool. There's nothing we can do against&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.python.org/3/library/functions.html#eval"&gt;eval&lt;/a&gt; and &lt;a class="reference external" href="https://docs.python.org/3/library/functions.html#exec"&gt;exec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;star import &lt;tt class="docutils literal"&gt;from some_module import *&lt;/tt&gt; even if &lt;tt class="docutils literal"&gt;beniget&lt;/tt&gt;, in a very conservative way, assumes that such import can define any identifier, which means it's likely to have a lot of &lt;tt class="docutils literal"&gt;USE&lt;/tt&gt;!&lt;/li&gt;
&lt;li&gt;assigning to &lt;tt class="docutils literal"&gt;globals()&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;locals()&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And plenty of other similar stuff. I can't blame you for using these features, that's part of &lt;a class="reference external" href="https://fr.wikipedia.org/wiki/Le_Scorpion_et_la_Grenouille"&gt;Python nature&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Also, note that &lt;tt class="docutils literal"&gt;beniget&lt;/tt&gt; analysis is not data dependant, so &lt;tt class="docutils literal"&gt;if 1: a = 1&lt;/tt&gt; does &lt;strong&gt;not&lt;/strong&gt; unconditionally defines &lt;tt class="docutils literal"&gt;a&lt;/tt&gt;!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="installation-and-stuff"&gt;
&lt;h3&gt;Installation and stuff&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;beniget&lt;/tt&gt; is available on &lt;a class="reference external" href="https://pypi.org/project/beniget/"&gt;PyPI&lt;/a&gt; and &lt;a class="reference external" href="https://github.com/serge-sans-paille/beniget/"&gt;GitHub&lt;/a&gt; under &lt;a class="reference external" href="https://github.com/serge-sans-paille/beniget/blob/master/LICENSE"&gt;BSD 3-clause&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It's tested using &lt;a class="reference external" href="https://pypi.org/project/tox/"&gt;tox&lt;/a&gt; on Python 2.7 and 3.6.&lt;/p&gt;
&lt;p&gt;It's already used as a foundation package of &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran"&gt;Pythran&lt;/a&gt; and &lt;a class="reference external" href="https://transonic.readthedocs.io/"&gt;Transonic&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="acknowledgment"&gt;
&lt;h3&gt;Acknowledgment&lt;/h3&gt;
&lt;p&gt;Thanks a lot to &lt;a class="reference external" href="http://www.legi.grenoble-inp.fr/people/Pierre.Augier/"&gt;Pierre Augier&lt;/a&gt; for motivating the
project and &lt;a class="reference external" href="http://www.legi.grenoble-inp.fr/web/?lang=fr"&gt;LEGI&lt;/a&gt; for funding
it!&lt;/p&gt;
&lt;p&gt;Also, thanks a bunch to Ashwin Vishnu, Pierrick Brunet and Jean Laroche for proof reading this post o/&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="compilation"></category></entry><entry><title>Source-to-source transformation of a Python kernel</title><link href="http://serge-sans-paille.github.io/pythran-stories/source-to-source-transformation-of-a-python-kernel.html" rel="alternate"></link><published>2019-03-06T00:00:00+01:00</published><updated>2019-03-06T00:00:00+01:00</updated><author><name>serge-sans-paille</name></author><id>tag:serge-sans-paille.github.io,2019-03-06:/pythran-stories/source-to-source-transformation-of-a-python-kernel.html</id><summary type="html">&lt;p class="first last"&gt;Pythran can also be used as a source-to-source transformation engine.
This post showcases some recent transformation on a high-level code.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;If you're curious or genuinely interested into how Pythran transforms your
code, but not brave enough to dive into the generated C++ code, Pythran
provides a compilation switch to dump the refined Python code, after
optimization and before it gets translated to C++. Internally, this relies on
the fact we have two backends: a C++ backend and a Python backend.&lt;/p&gt;
&lt;div class="section" id="using-pythran-as-a-source-to-source-compiler"&gt;
&lt;h2&gt;Using Pythran as a Source-to-Source Compiler&lt;/h2&gt;
&lt;p&gt;Pythran can be used as a source-to-source engine through the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-P&lt;/span&gt;&lt;/tt&gt; flag.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;cat&lt;span class="w"&gt; &lt;/span&gt;sample.py
def&lt;span class="w"&gt; &lt;/span&gt;fibo&lt;span class="o"&gt;(&lt;/span&gt;n&lt;span class="o"&gt;)&lt;/span&gt;:
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;fibo&lt;span class="o"&gt;(&lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;+&lt;span class="w"&gt; &lt;/span&gt;fibo&lt;span class="o"&gt;(&lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
def&lt;span class="w"&gt; &lt;/span&gt;test&lt;span class="o"&gt;()&lt;/span&gt;:
&lt;span class="w"&gt;    &lt;/span&gt;print&lt;span class="o"&gt;(&lt;/span&gt;fibo&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;-P&lt;span class="w"&gt; &lt;/span&gt;sample.py
def&lt;span class="w"&gt; &lt;/span&gt;fibo&lt;span class="o"&gt;(&lt;/span&gt;n&lt;span class="o"&gt;)&lt;/span&gt;:
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;&amp;lt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;fibo&lt;span class="o"&gt;((&lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;+&lt;span class="w"&gt; &lt;/span&gt;fibo&lt;span class="o"&gt;((&lt;/span&gt;n&lt;span class="w"&gt; &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))))&lt;/span&gt;
def&lt;span class="w"&gt; &lt;/span&gt;test&lt;span class="o"&gt;()&lt;/span&gt;:
&lt;span class="w"&gt;    &lt;/span&gt;__builtin__.print&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;55&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;__builtin__.None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What happened? Pythran analyzed the body of &lt;tt class="docutils literal"&gt;fibo&lt;/tt&gt; and found out it was a
pure function (no effect on global state nor arguments) called with a literal,
so it performed aggressive constant propagation. It also computed def-use
chains which helps making every builtin explicit (&lt;tt class="docutils literal"&gt;__builtin__.print&lt;/tt&gt;). Based
on the the control flow graph of each function, it also adds &lt;tt class="docutils literal"&gt;return None&lt;/tt&gt;
wherever Python would implicit add it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="advanced-transformations"&gt;
&lt;h2&gt;Advanced Transformations&lt;/h2&gt;
&lt;p&gt;An alluring aspect of Python for scientists is the high level constructs it
proposes. For instance, the following code implements an (arguably) high level
way of computing the wighted sum between five integers:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# wsum.py&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wsum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;.1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code is okay from Numpy point of view, but how does Pythran handle it?
Surely, building a temporary array just for the sake of performing a
point-to-point array operation is not the most efficient way of performing
these operation!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;-P&lt;span class="w"&gt; &lt;/span&gt;wsum.py
import&lt;span class="w"&gt; &lt;/span&gt;numpy&lt;span class="w"&gt; &lt;/span&gt;as&lt;span class="w"&gt; &lt;/span&gt;__pythran_import_numpy
def&lt;span class="w"&gt; &lt;/span&gt;wsum&lt;span class="o"&gt;(&lt;/span&gt;v,&lt;span class="w"&gt; &lt;/span&gt;w,&lt;span class="w"&gt; &lt;/span&gt;x,&lt;span class="w"&gt; &lt;/span&gt;y,&lt;span class="w"&gt; &lt;/span&gt;z&lt;span class="o"&gt;)&lt;/span&gt;:
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;__builtin__.sum&lt;span class="o"&gt;(((&lt;/span&gt;v&lt;span class="w"&gt; &lt;/span&gt;*&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.1&lt;span class="o"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;w&lt;span class="w"&gt; &lt;/span&gt;*&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.2&lt;span class="o"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;x&lt;span class="w"&gt; &lt;/span&gt;*&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.3&lt;span class="o"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;y&lt;span class="w"&gt; &lt;/span&gt;*&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.2&lt;span class="o"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;z&lt;span class="w"&gt; &lt;/span&gt;*&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.1&lt;span class="o"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fascinating! (Yes, I'm self-congratulating there). Pythran understood that a
Numpy operation on fixed-size array was involved, so it first performed the
broadcasting on its own, resulting in:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;__pythran_import_numpy&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wsum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;__builtin__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__pythran_import_numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then it used the fact that sum can take any iterable as parameter to prune the
call to &lt;tt class="docutils literal"&gt;np.array&lt;/tt&gt;. The nice thing with tuple of homogeneous type as
parameter is that the C++ backend can use it to generate something equivalent
to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;std::array&amp;lt;double,&lt;/span&gt; 5&amp;gt;&lt;/tt&gt;, avoiding a heap allocation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-assembly-worker"&gt;
&lt;h2&gt;The Assembly Worker&lt;/h2&gt;
&lt;p&gt;Let's inspect the assembly generated from the above code, instantiated with the
Pythran annotation &lt;tt class="docutils literal"&gt;#pythran export wsum(float64, float64, float64, float64,
float64)&lt;/tt&gt; and compiled with Clang 6.0&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;CXX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;clang++&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;wsum.py
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;objdump&lt;span class="w"&gt; &lt;/span&gt;-S&lt;span class="w"&gt; &lt;/span&gt;-C&lt;span class="w"&gt; &lt;/span&gt;wsum.*.so
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
...&lt;span class="w"&gt;  &lt;/span&gt;movsd&lt;span class="w"&gt;  &lt;/span&gt;0x12d4&lt;span class="o"&gt;(&lt;/span&gt;%rip&lt;span class="o"&gt;)&lt;/span&gt;,%xmm0
...&lt;span class="w"&gt;  &lt;/span&gt;movsd&lt;span class="w"&gt;  &lt;/span&gt;0x18&lt;span class="o"&gt;(&lt;/span&gt;%rsp&lt;span class="o"&gt;)&lt;/span&gt;,%xmm2
...&lt;span class="w"&gt;  &lt;/span&gt;mulsd&lt;span class="w"&gt;  &lt;/span&gt;%xmm0,%xmm2
...&lt;span class="w"&gt;  &lt;/span&gt;movsd&lt;span class="w"&gt;  &lt;/span&gt;0x12ca&lt;span class="o"&gt;(&lt;/span&gt;%rip&lt;span class="o"&gt;)&lt;/span&gt;,%xmm1
...&lt;span class="w"&gt;  &lt;/span&gt;movsd&lt;span class="w"&gt;  &lt;/span&gt;0x10&lt;span class="o"&gt;(&lt;/span&gt;%rsp&lt;span class="o"&gt;)&lt;/span&gt;,%xmm3
...&lt;span class="w"&gt;  &lt;/span&gt;mulsd&lt;span class="w"&gt;  &lt;/span&gt;%xmm1,%xmm3
...&lt;span class="w"&gt;  &lt;/span&gt;movsd&lt;span class="w"&gt;  &lt;/span&gt;0x8&lt;span class="o"&gt;(&lt;/span&gt;%rsp&lt;span class="o"&gt;)&lt;/span&gt;,%xmm4
...&lt;span class="w"&gt;  &lt;/span&gt;mulsd&lt;span class="w"&gt;  &lt;/span&gt;0x12ba&lt;span class="o"&gt;(&lt;/span&gt;%rip&lt;span class="o"&gt;)&lt;/span&gt;,%xmm4
...&lt;span class="w"&gt;  &lt;/span&gt;movsd&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;%rsp&lt;span class="o"&gt;)&lt;/span&gt;,%xmm5
...&lt;span class="w"&gt;  &lt;/span&gt;mulsd&lt;span class="w"&gt;  &lt;/span&gt;%xmm0,%xmm5
...&lt;span class="w"&gt;  &lt;/span&gt;movsd&lt;span class="w"&gt;  &lt;/span&gt;0x20&lt;span class="o"&gt;(&lt;/span&gt;%rsp&lt;span class="o"&gt;)&lt;/span&gt;,%xmm0
...&lt;span class="w"&gt;  &lt;/span&gt;mulsd&lt;span class="w"&gt;  &lt;/span&gt;%xmm1,%xmm0
...&lt;span class="w"&gt;  &lt;/span&gt;addsd&lt;span class="w"&gt;  &lt;/span&gt;%xmm5,%xmm0
...&lt;span class="w"&gt;  &lt;/span&gt;addsd&lt;span class="w"&gt;  &lt;/span&gt;%xmm4,%xmm0
...&lt;span class="w"&gt;  &lt;/span&gt;addsd&lt;span class="w"&gt;  &lt;/span&gt;%xmm3,%xmm0
...&lt;span class="w"&gt;  &lt;/span&gt;addsd&lt;span class="w"&gt;  &lt;/span&gt;%xmm2,%xmm0
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No single call to a memory allocator, no branching, just a plain listing of
&lt;tt class="docutils literal"&gt;movsd&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;mulsd&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;addsd&lt;/tt&gt;. And quite some register pressure, but
that's how it is.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="just-perf-it"&gt;
&lt;h2&gt;Just &lt;tt class="docutils literal"&gt;perf&lt;/tt&gt; it&lt;/h2&gt;
&lt;p&gt;As a tribute to Victor Stinner's &lt;tt class="docutils literal"&gt;perf&lt;/tt&gt; module, and as a conclusion to this
small experiment, let's ensure we get some speedup, event for such a small
kernel:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;rm&lt;span class="w"&gt; &lt;/span&gt;*.so
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;perf&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;-s&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;from wsum import wsum&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;wsum(1.,2.,3.,4.,5.)&amp;#39;&lt;/span&gt;
.....................
Mean&lt;span class="w"&gt; &lt;/span&gt;+-&lt;span class="w"&gt; &lt;/span&gt;std&lt;span class="w"&gt; &lt;/span&gt;dev:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;.73&lt;span class="w"&gt; &lt;/span&gt;us&lt;span class="w"&gt; &lt;/span&gt;+-&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.11&lt;span class="w"&gt; &lt;/span&gt;us
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;CXX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;clang++&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;wsum.py
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;perf&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;-s&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;from wsum import wsum&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;wsum(1.,2.,3.,4.,5.)&amp;#39;&lt;/span&gt;
.....................
Mean&lt;span class="w"&gt; &lt;/span&gt;+-&lt;span class="w"&gt; &lt;/span&gt;std&lt;span class="w"&gt; &lt;/span&gt;dev:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;190&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ns&lt;span class="w"&gt; &lt;/span&gt;+-&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ns
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And out of curiosity, let's check the timing with the transformed Python kernel.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;rm&lt;span class="w"&gt; &lt;/span&gt;*.so
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;-P&lt;span class="w"&gt; &lt;/span&gt;wsum.py&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sed&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s,__builtin__.,,&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;wsum2.py
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;perf&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;-s&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;from wsum2 import wsum&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;wsum(1.,2.,3.,4.,5.)&amp;#39;&lt;/span&gt;
.....................
Mean&lt;span class="w"&gt; &lt;/span&gt;+-&lt;span class="w"&gt; &lt;/span&gt;std&lt;span class="w"&gt; &lt;/span&gt;dev:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;308&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ns&lt;span class="w"&gt; &lt;/span&gt;+-&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;ns
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Fine! Pythran did the job in both cases :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="final-words"&gt;
&lt;h2&gt;Final Words&lt;/h2&gt;
&lt;p&gt;The optimisations done by Pythran are meant at optimising its internal
representation so that translated code compiles to an efficient native library.
Still, being able to debug it at Python level is very valuable, and it can even
generate faster Python code in some cases!&lt;/p&gt;
&lt;/div&gt;
</content><category term="compilation"></category></entry><entry><title>from pythran import typing</title><link href="http://serge-sans-paille.github.io/pythran-stories/from-pythran-import-typing.html" rel="alternate"></link><published>2016-12-10T00:00:00+01:00</published><updated>2016-12-10T00:00:00+01:00</updated><author><name>serge-sans-paille</name></author><id>tag:serge-sans-paille.github.io,2016-12-10:/pythran-stories/from-pythran-import-typing.html</id><summary type="html">&lt;p class="first last"&gt;Pythran recently gained a type checking ability, called &lt;em&gt;tog&lt;/em&gt;. And given the size of the diff, that's not some minor improvement! Let's see what happened in terms of better robustness and error reporting :-)&lt;/p&gt;
</summary><content type="html">&lt;p&gt;Pythran is currently part of &lt;a class="reference external" href="http://opendreamkit.org/"&gt;OpenDreamKit&lt;/a&gt;,
a project that aims at improving the open source computational mathematics
ecosystem.&lt;/p&gt;
&lt;p&gt;The goal of Pythran is indeed to improve some Python kernel computations, but
there's something that actually makes Pythran difficult to use for new
comers. What is it? Let's have a look at the following Python code, inspired by
a &lt;a class="reference external" href="http://stackoverflow.com/questions/13815719/creating-grid-with-numpy-performance"&gt;stack overflow thread&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# create_grid.py&lt;/span&gt;

&lt;span class="c1"&gt;#pythran export create_grid(float [])&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;create_grid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;[:,:,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;[:,:,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="n"&gt;fast_grid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fast_grid&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An attempt to compile it with Pythran would return a very long C++ template instantiation trace, with very little clue concerning the origin of the problem.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;create_grid.py
In&lt;span class="w"&gt; &lt;/span&gt;file&lt;span class="w"&gt; &lt;/span&gt;included&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;/tmp/tmpP0xYa2.cpp:10:
In&lt;span class="w"&gt; &lt;/span&gt;file&lt;span class="w"&gt; &lt;/span&gt;included&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;./pythran/pythonic/include/types/ndarray.hpp:12:
In&lt;span class="w"&gt; &lt;/span&gt;file&lt;span class="w"&gt; &lt;/span&gt;included&lt;span class="w"&gt; &lt;/span&gt;from&lt;span class="w"&gt; &lt;/span&gt;./pythran/pythonic/include/utils/broadcast_copy.hpp:4:
./pythran/pythonic/include/types/tuple.hpp:122:25:&lt;span class="w"&gt; &lt;/span&gt;error:&lt;span class="w"&gt; &lt;/span&gt;array&lt;span class="w"&gt; &lt;/span&gt;is&lt;span class="w"&gt; &lt;/span&gt;too&lt;span class="w"&gt; &lt;/span&gt;large&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;18446744073709551615&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;elements&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;value_type&lt;span class="w"&gt; &lt;/span&gt;buffer&lt;span class="o"&gt;[&lt;/span&gt;N&lt;span class="w"&gt; &lt;/span&gt;?&lt;span class="w"&gt; &lt;/span&gt;N&lt;span class="w"&gt; &lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;^~~~~~~~~
./pythran/pythonic/include/types/numpy_iexpr.hpp:57:26:&lt;span class="w"&gt; &lt;/span&gt;note:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;instantiation&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;template&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;pythonic::types::array&amp;lt;long, 18446744073709551615&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;requested&lt;span class="w"&gt; &lt;/span&gt;here
&lt;span class="w"&gt;      &lt;/span&gt;array&amp;lt;long,&lt;span class="w"&gt; &lt;/span&gt;value&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;_shape&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;                         &lt;/span&gt;^
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="w"&gt;                                    &lt;/span&gt;^
./pythran/pythonic/include/utils/seq.hpp:19:19:&lt;span class="w"&gt; &lt;/span&gt;note:&lt;span class="w"&gt; &lt;/span&gt;use&lt;span class="w"&gt; &lt;/span&gt;-ftemplate-depth&lt;span class="o"&gt;=&lt;/span&gt;N&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;increase&lt;span class="w"&gt; &lt;/span&gt;recursive&lt;span class="w"&gt; &lt;/span&gt;template&lt;span class="w"&gt; &lt;/span&gt;instantiation&lt;span class="w"&gt; &lt;/span&gt;depth
&lt;span class="w"&gt;    &lt;/span&gt;struct&lt;span class="w"&gt; &lt;/span&gt;gens&lt;span class="w"&gt; &lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;gens&amp;lt;N&lt;span class="w"&gt; &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;N&lt;span class="w"&gt; &lt;/span&gt;-&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;S...&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;                  &lt;/span&gt;^
&lt;span class="m"&gt;3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;errors&lt;span class="w"&gt; &lt;/span&gt;generated.
CRITICAL&lt;span class="w"&gt; &lt;/span&gt;Cover&lt;span class="w"&gt; &lt;/span&gt;me&lt;span class="w"&gt; &lt;/span&gt;Jack.&lt;span class="w"&gt; &lt;/span&gt;Jack?&lt;span class="w"&gt; &lt;/span&gt;Jaaaaack!!!!
E:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;error: Command &amp;quot;clang++-3.8 -DNDEBUG -g -fwrapv -O2 -Wall -fno-strict-aliasing -g -O2 -fPIC -DUSE_GMP -DENABLE_PYTHON_MODULE -D__PYTHRAN__=2 -I./pythran -I./pythran/pythonic/patch -I/home/serge/.venvs/pythran/local/lib/python2.7/site-packages/numpy/core/include -I/usr/include/python2.7 -c /tmp/tmpP0xYa2.cpp -o /tmp/tmpM2Eiso/tmp/tmpP0xYa2.o -std=c++11 -fno-math-errno -w -fwhole-program -fvisibility=hidden&amp;quot; failed with exit status 1&amp;#39;&lt;/span&gt;,&lt;span class="o"&gt;)&lt;/span&gt;

What&lt;span class="w"&gt; &lt;/span&gt;we&lt;span class="w"&gt; &lt;/span&gt;now&lt;span class="w"&gt; &lt;/span&gt;have&lt;span class="w"&gt; &lt;/span&gt;is&lt;span class="w"&gt; &lt;/span&gt;a&lt;span class="w"&gt; &lt;/span&gt;slightly&lt;span class="w"&gt; &lt;/span&gt;friendlier&lt;span class="w"&gt; &lt;/span&gt;message:
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;create_grid.py
CRITICAL&lt;span class="w"&gt; &lt;/span&gt;You&lt;span class="w"&gt; &lt;/span&gt;shall&lt;span class="w"&gt; &lt;/span&gt;not&lt;span class="w"&gt; &lt;/span&gt;pass!
E:&lt;span class="w"&gt; &lt;/span&gt;Dimension&lt;span class="w"&gt; &lt;/span&gt;mismatch&lt;span class="w"&gt; &lt;/span&gt;when&lt;span class="w"&gt; &lt;/span&gt;slicing&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;Array&lt;span class="o"&gt;[&lt;/span&gt;2d,&lt;span class="w"&gt; &lt;/span&gt;float&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;create_grid.py,&lt;span class="w"&gt; &lt;/span&gt;line&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;7&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Indeed, the correct declaration for &lt;tt class="docutils literal"&gt;z&lt;/tt&gt; was &lt;tt class="docutils literal"&gt;z = &lt;span class="pre"&gt;np.zeros((N,&lt;/span&gt; N, 3))&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="section" id="a-quick-glance-at-pythran-typing-system"&gt;
&lt;h2&gt;A Quick Glance at Pythran Typing System&lt;/h2&gt;
&lt;p&gt;As you probably know, Python uses a dynamic type system, often  called &lt;em&gt;duck typing&lt;/em&gt;: what
matters is not the type of an object, but its structure, i.e. the available
methods and fields: &lt;em&gt;If it walks like a duck and talks like a duck, then it's a
duck&lt;/em&gt;. That's a kind of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Structural_type_system"&gt;structural typing&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;On the opposite side C++ uses a static type system, and if you adhere to OOP
&lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-1"&gt;[1]&lt;/a&gt; you may require an object to derive from the &lt;tt class="docutils literal"&gt;Duck&lt;/tt&gt; class to be
considered a duck; That's a kind of &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Nominal_type_system"&gt;nominal typing&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Pythran uses a trick to make both world meet: &lt;em&gt;ad-hoc polymorphism&lt;/em&gt;, as
supported in C++ through &lt;tt class="docutils literal"&gt;template&lt;/tt&gt; meta programing. Upon a template
instantiation, there's no type name verification, only a check that given
methods and attributes make sense in the current context. And that's exactly
what we need to get closer to Python typing!&lt;/p&gt;
&lt;p&gt;This all is very nice, except in the case of a bad typing. Consider this trivial
Python code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;twice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;integer, for instance &lt;tt class="docutils literal"&gt;str&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;list&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;. The C++ equivalent would
be (taking into account move semantics):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;twice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Python's case, type checking is done at runtime, during a lookup in &lt;tt class="docutils literal"&gt;s&lt;/tt&gt; for
a &lt;tt class="docutils literal"&gt;__mul__&lt;/tt&gt; magic method. In C++ it's done at compile time, when performing
instantiation of &lt;tt class="docutils literal"&gt;twice&lt;/tt&gt; for a given type value of &lt;tt class="docutils literal"&gt;T&lt;/tt&gt;. What lacked was a
human-readable error message to warn about the coming winter. And that's
exactly the topic of this post ;-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-few-words-about-mypy"&gt;
&lt;h2&gt;A Few Words About MyPy&lt;/h2&gt;
&lt;p&gt;Type hints, as introduced by &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-0484/"&gt;PEP484&lt;/a&gt;, make it possible to leverage on
arbitrary function annotations introduced by &lt;a class="reference external" href="https://www.python.org/dev/peps/pep-3107"&gt;PEP 3107&lt;/a&gt; to specify the expected type of a
function parameter and its resulting return type. No check occur at runtime, but
a third party compiler, say &lt;a class="reference external" href="http://mypy-lang.org/"&gt;MyPy&lt;/a&gt; can take advantage
of these hints to perform an ahead-of-time check. And that's &lt;strong&gt;great&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;In this post, we use the type annotation introduced by PEP484 and used in
MyPy to describe types. &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; is an integer, &lt;tt class="docutils literal"&gt;List[str]&lt;/tt&gt; is a list of
string and so on.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;So, did we trade &lt;tt class="docutils literal"&gt;#pythran export twice(str)&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;def twice(s: str):&lt;/tt&gt;? No.
Did we consider the option? Yes. First there's the issue of MyPy only running
on Python3. It can process Python2 code, but it runs on Python3. We've been
struggling so much to keep Python2.7 compatibility in addition to the recent
addition of broader Python3 support. We're not going to leave it apart without
good reasons.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;It also turns out that the &lt;tt class="docutils literal"&gt;typing&lt;/tt&gt; module has a different internal API
between Python2 and Python3. This makes it quite difficult to use for my
purpose. What a joy to discover this when you think you're done with all
your tests :-/&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;No, the main problem is &lt;a class="reference external" href="https://github.com/python/mypy/issues/978"&gt;this MyPy issue&lt;/a&gt; that basically states that Numpy
does not fit into the model:&lt;/p&gt;
&lt;blockquote&gt;
Of course, the best behavior would be to provide a stub for Numpy, but some
features in Numpy make it difficult to provide a good stub&lt;/blockquote&gt;
&lt;p&gt;Meanwhile, someone that did not read this issue wrote &lt;a class="reference external" href="https://github.com/machinalis/mypy-data/tree/master/numpy-mypy"&gt;A Numpy stub for MyPy&lt;/a&gt;. It turns
out that &lt;a class="reference external" href="http://www.machinalis.com/blog/writing-type-stubs-for-numpy/"&gt;it' **is** a pain&lt;/a&gt;, mostly due to
the flexibility of many Numpy methods.&lt;/p&gt;
&lt;p&gt;Additionally, Pythran currently infers type inter-procedurally, while MyPy
requires type annotation on every functions, to keep the problem within
reasonable bounds.&lt;/p&gt;
&lt;p&gt;But wait. MyPy author did his PhD on the subject, and he now works hand in hand
with Guildo van Rossum on the subject. Is there any chance for us to do a
better job? Let's be honest. There is not.&lt;/p&gt;
&lt;p&gt;What can we do in such a situation? Take advantage of some extra assumptions
Pythran can afford. We focus on scientific computing, all existing types are
known (no user-defined types in Pythran) and we only need to handle small size
kernels, so we can spend some extra computing resources in the process.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-variant-of-hindley-milner-for-pythran"&gt;
&lt;h2&gt;A Variant of Hindley-Milner for Pythran&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"&gt;Hindley-Milner (HM)&lt;/a&gt; is
a relatively easy to understand type system that supports parametric
polymorphism. A simple implementation has been &lt;a class="reference external" href="http://smallshire.org.uk/sufficientlysmall/2010/04/11/a-hindley-milner-type-inference-implementation-in-python/"&gt;written in Python&lt;/a&gt;,
but &lt;em&gt;not&lt;/em&gt; for Python, even not for the subset supported by Pythran.&lt;/p&gt;
&lt;p&gt;The main issue comes with overloaded functions. Consider the &lt;tt class="docutils literal"&gt;map&lt;/tt&gt; function:
it has a varying number of parameters, and for a given number of parameters,
two possible overloads exist (the first argument being &lt;tt class="docutils literal"&gt;None&lt;/tt&gt; or a
&lt;tt class="docutils literal"&gt;Callable&lt;/tt&gt;).  Some extra stuff are not as critical but also important: it's
not possible to infer implicit option types (the one that comes with usage of
&lt;tt class="docutils literal"&gt;None&lt;/tt&gt;). Ocaml uses &lt;tt class="docutils literal"&gt;Some&lt;/tt&gt; as a counterpart of &lt;tt class="docutils literal"&gt;None&lt;/tt&gt; to handle this
issue. but there's no such hint in Python (and we don't want to introduce one).&lt;/p&gt;
&lt;p&gt;Still, the whole subject of typing is reaaaaaalllllly difficult, and I wanted
to stick as close as possible to Hindley-Milner because of its simplicity. So
what got introduced is the concept of &lt;tt class="docutils literal"&gt;MultiType&lt;/tt&gt;, which is the type of an
object that can hold several types at the same time. So that's not exactly a
&lt;tt class="docutils literal"&gt;UnionType&lt;/tt&gt; which is the type of an object that can be of one type among
many. The difference exists because of the situation described by the following code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In that case foo really has two types, namely &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Callable[[Any],&lt;/span&gt; None]&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Callalble[[Any,&lt;/span&gt; Any], None]&lt;/tt&gt;. That's what &lt;tt class="docutils literal"&gt;MultiType&lt;/tt&gt; represents.&lt;/p&gt;
&lt;div class="section" id="handling-overloading"&gt;
&lt;h3&gt;Handling Overloading&lt;/h3&gt;
&lt;p&gt;So we handle overloading through a unique object that has a specific type, a
&lt;tt class="docutils literal"&gt;MultiType&lt;/tt&gt; that is just a list of possible types.&lt;/p&gt;
&lt;p&gt;Abusing from &lt;tt class="docutils literal"&gt;Multiype&lt;/tt&gt; can quickly make the combinatorics of the type
possibilities go wild, so we had to make a decision. Consider the following code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;in&lt;/tt&gt; operator could be implemented as a &lt;tt class="docutils literal"&gt;MultiType&lt;/tt&gt;, enumerating the
possible valid signature (remember we know of all possible types in Pythran):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Callable[[List[T0],&lt;/span&gt; T0], bool]&lt;/tt&gt;, a function that takes a list of &lt;tt class="docutils literal"&gt;T0&lt;/tt&gt; and a &lt;tt class="docutils literal"&gt;T0&lt;/tt&gt; and returns a boolean,&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Callable[[str,&lt;/span&gt; str], bool]&lt;/tt&gt;, a function that takes two strings and returns a boolean,&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And so on, including for numpy arrays, but we'll comme back to this later and
assume for now we only have these two types.  So what is the type of &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;? From the
&lt;tt class="docutils literal"&gt;x in y&lt;/tt&gt; expression, HM tells us that &lt;tt class="docutils literal"&gt;x&lt;/tt&gt; can be a list of &lt;tt class="docutils literal"&gt;T0&lt;/tt&gt;, and in
that case &lt;tt class="docutils literal"&gt;y&lt;/tt&gt; must be of type &lt;tt class="docutils literal"&gt;T0&lt;/tt&gt;, &lt;strong&gt;or&lt;/strong&gt; &lt;tt class="docutils literal"&gt;x&lt;/tt&gt; is a string and so must be
&lt;tt class="docutils literal"&gt;y&lt;/tt&gt;. And in both cases, a boolean is returned.&lt;/p&gt;
&lt;p&gt;We could consider both alternatives, follow the two type paths and
in the end, compute the signature of &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; as a &lt;tt class="docutils literal"&gt;MultiType&lt;/tt&gt; holding the
outcome of all paths. But that could mean a lot! What we do is an
over-approximation: what is the common structure between &lt;tt class="docutils literal"&gt;List[T0]&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;str&lt;/tt&gt;? Both are iterable, therefeore &lt;tt class="docutils literal"&gt;x&lt;/tt&gt; must be iterable. Nothing good comes
from &lt;tt class="docutils literal"&gt;T0&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;str&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;bool&lt;/tt&gt; compared to &lt;tt class="docutils literal"&gt;bool&lt;/tt&gt; results in a
&lt;tt class="docutils literal"&gt;bool&lt;/tt&gt;, so in the end &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; takes an iterable and any value, and returns a
boolean. That's not as strict as it could be, but that's definitively enough.
However our type system is no longer &lt;em&gt;sound&lt;/em&gt; (it does not reject all bad program).&lt;/p&gt;
&lt;p&gt;In order to make it easier to perform this approximation, we chose a dedicated representation for containers. In our type system (oh, it's named &lt;em&gt;tog&lt;/em&gt; by the way, so in the tog type system), containers are roughly described as a tuple of &lt;tt class="docutils literal"&gt;(name, sized, key, value, iter)&lt;/tt&gt;:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;List[T0]&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(List, Sized, int, T0, T0)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;Set[T0]&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(Set, Sized, NoKey, T0, T0)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;Dict[T0, T1]&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(Dict, Sized, T0, T1, T0)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;str&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(Str, Sized, int, Str, Str)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;Generator[T0]&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(Generator, NoSized, NoKey, T0, T0)&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a consequence, an &lt;tt class="docutils literal"&gt;Iterable[T0]&lt;/tt&gt;, to be compatible with the
over-approximation defined above, is a &lt;tt class="docutils literal"&gt;(Any, Any, Any, Any, T0)&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="handling-option-types"&gt;
&lt;h3&gt;Handling Option Types&lt;/h3&gt;
&lt;p&gt;When HM runs on the following Python code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It runs into some troubles. The &lt;tt class="docutils literal"&gt;return&lt;/tt&gt; from the &lt;tt class="docutils literal"&gt;True&lt;/tt&gt; branch sets the
return type of &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; but the one from the &lt;tt class="docutils literal"&gt;False&lt;/tt&gt; branch sets it
to &lt;tt class="docutils literal"&gt;None&lt;/tt&gt;. How could we make this unification valid? Option types are
generally described as a parametric type, &lt;tt class="docutils literal"&gt;Optional[T0]&lt;/tt&gt;. To be able to unify
&lt;tt class="docutils literal"&gt;int&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;None&lt;/tt&gt;, we would instead need to unify &lt;tt class="docutils literal"&gt;Optional[int]&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;None&lt;/tt&gt;, thus marking &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; as &lt;tt class="docutils literal"&gt;Optional[int]&lt;/tt&gt;, which does not work, because
&lt;tt class="docutils literal"&gt;range&lt;/tt&gt; expects an &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The solution we have adopted is to make type inference control-flow sensitive. When
meeting an &lt;tt class="docutils literal"&gt;if&lt;/tt&gt;, we generate a new copy of the variable environment for each
branch, and we &lt;em&gt;merge&lt;/em&gt; (not &lt;em&gt;unify&lt;/em&gt;) the environments.&lt;/p&gt;
&lt;p&gt;Likewise, if the condition is &lt;em&gt;explicitely&lt;/em&gt; a check for &lt;tt class="docutils literal"&gt;None&lt;/tt&gt;, as in:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;stuff&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;stuff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the environment in the &lt;tt class="docutils literal"&gt;True&lt;/tt&gt; branch holds the &lt;tt class="docutils literal"&gt;None&lt;/tt&gt; type for &lt;tt class="docutils literal"&gt;a&lt;/tt&gt;, and
the &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; type in the &lt;tt class="docutils literal"&gt;False&lt;/tt&gt; branch. This could be improved, as we support
only a few patterns as the condition expression, there is something more
generic to be done there.&lt;/p&gt;
&lt;p&gt;This even led to improvement in our test base, as the following code was no longer correct:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Type inference computes that v is of type &lt;tt class="docutils literal"&gt;Optional[T0]&lt;/tt&gt;, which is not compatible with &lt;tt class="docutils literal"&gt;v + 1&lt;/tt&gt; and a &lt;tt class="docutils literal"&gt;PythranTypeError&lt;/tt&gt; is raised. A compatible way to write this would be:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;  &lt;span class="c1"&gt;# or do stuff&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="handling-type-promotion"&gt;
&lt;h3&gt;Handling Type Promotion&lt;/h3&gt;
&lt;p&gt;It's not uncommon to find this kind of code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;3.14&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And there's nothing wrong with this in Python, but is this a type error for
Pythran? In classical HM systems, that's a type error: &lt;tt class="docutils literal"&gt;[]&lt;/tt&gt; is of type
&lt;tt class="docutils literal"&gt;List[TO]&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;list.append&lt;/tt&gt; is of type &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Callable[[List[T0],&lt;/span&gt; T0], None]&lt;/tt&gt; so
unification sets &lt;tt class="docutils literal"&gt;T0&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; after first &lt;tt class="docutils literal"&gt;append&lt;/tt&gt;, and fails upon the
second &lt;tt class="docutils literal"&gt;append&lt;/tt&gt; because unification between an &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; and a &lt;tt class="docutils literal"&gt;float&lt;/tt&gt; fails.&lt;/p&gt;
&lt;p&gt;Looking back in Python typing history, it seems that &lt;a class="reference external" href="https://shedskin.github.io/"&gt;shedskin&lt;/a&gt; made the decision to consider it's not an error
(see the &lt;a class="reference external" href="http://shed-skin.blogspot.fr/2011/09/shed-skin-09.html"&gt;blogpost announce on the topic&lt;/a&gt;. Several test cases
of Pythran test suite would fail with a stricter typing, so let's try to
achieve the same behavior as Shedskin, within HM.&lt;/p&gt;
&lt;p&gt;The trick here is to consider a scalar as a tuple of four elements &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-2"&gt;[0]&lt;/a&gt;, one per
scalar type we want to support. And then apply the following rule: the actual
type of the scalar is the type of the first non variable type, starting from
the lower index. Under that assumption,&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;bool&lt;/tt&gt; is a &lt;tt class="docutils literal"&gt;(T0, T1, T2, bool)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;an &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; is a &lt;tt class="docutils literal"&gt;(T0, T1, int, T2)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;float&lt;/tt&gt; is a &lt;tt class="docutils literal"&gt;(T0, float, T1, T2)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;a &lt;tt class="docutils literal"&gt;complex&lt;/tt&gt; is a &lt;tt class="docutils literal"&gt;(complex, T0, T1, T2)&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When unifying an &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; with a &lt;tt class="docutils literal"&gt;float&lt;/tt&gt;, regular unification yields &lt;tt class="docutils literal"&gt;(T0,
float, int, T2)&lt;/tt&gt; which is a &lt;tt class="docutils literal"&gt;float&lt;/tt&gt; according to the previous definition.&lt;/p&gt;
&lt;p&gt;If we want to enforce an &lt;tt class="docutils literal"&gt;int&lt;/tt&gt;, say as argument of &lt;tt class="docutils literal"&gt;range&lt;/tt&gt;, then we can
define &lt;tt class="docutils literal"&gt;strict_int&lt;/tt&gt; as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;(no-complex,&lt;/span&gt; &lt;span class="pre"&gt;no-float,&lt;/span&gt; int, T0)&lt;/tt&gt; which still allows
up-casting from &lt;tt class="docutils literal"&gt;bool&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; but prevents up-casting from &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; to
&lt;tt class="docutils literal"&gt;float&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;&lt;tt class="docutils literal"&gt;numpy&lt;/tt&gt; introduces many sized type for integers, floating point numbers
and complex numbers, with a set of rules to handle conversion between one
and the other. As these conversions are generally possible in &lt;tt class="docutils literal"&gt;numpy&lt;/tt&gt;
(i.e. they dont raise a &lt;tt class="docutils literal"&gt;TypeError&lt;/tt&gt;), we just use four scalar types:
&lt;tt class="docutils literal"&gt;bool`, ``int&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;complex&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;float&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;long&lt;/tt&gt; is merged into
&lt;tt class="docutils literal"&gt;int&lt;/tt&gt;, which also makes the Python2/3 compatibility easier.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="handling-ndarray-type"&gt;
&lt;h3&gt;Handling NDArray Type&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;numpy.ndarray&lt;/tt&gt; is the corner stone of the &lt;tt class="docutils literal"&gt;numpy&lt;/tt&gt; package. And it's
super-flexible, allowing all kinds of broadcasting, reshaping, up-casting etc.
Even if Pythran is far from supporting all of its features, it does support a
wide set. The good news is that Pythran supports a lower version of &lt;tt class="docutils literal"&gt;ndarray&lt;/tt&gt;,
where the number of dimensions of an array does not change: it cannot be
reshaped in place. For instance the C++ type returned by &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;numpy.ones((10,&lt;/span&gt;
10))&lt;/tt&gt; is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;types::ndarray&amp;lt;double&lt;/span&gt; &lt;span class="pre"&gt;/*dtype*/,&lt;/span&gt; 2 &lt;span class="pre"&gt;/*nbdim*/&amp;gt;&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;We've extended the &lt;tt class="docutils literal"&gt;typing&lt;/tt&gt; module to provide &lt;tt class="docutils literal"&gt;NDArray&lt;/tt&gt;. For Pythran, the
Python equivalent of the above C++ type is &lt;tt class="docutils literal"&gt;NDArray[float, :, :]&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;And as we want it to be compatible with the way we defined an &lt;tt class="docutils literal"&gt;Iterable&lt;/tt&gt;, an &lt;tt class="docutils literal"&gt;NDArray&lt;/tt&gt; is actually a:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;List[T0]&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(List, Sized, int, T0, T0)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;Dict[T0, T1]&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(Dict, Sized, T0, T1, T0)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;NDArray[complex, :]&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(Array, Sized, T0, complex, complex)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;NDArray[complex, :, :]&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(Array, Sized, T0, complex, NDArray[complex, :])&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;NDArray[complex, :, :, :]&lt;/tt&gt; is considered as &lt;tt class="docutils literal"&gt;(Array, Sized, T0, complex, NDArray[complex, :, :])&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That's a recursive definition, and that's pretty useful when used with our
&lt;tt class="docutils literal"&gt;MultiType&lt;/tt&gt; resolution. If we need to merge an &lt;tt class="docutils literal"&gt;NDArray[complex, :, :]&lt;/tt&gt; and
an &lt;tt class="docutils literal"&gt;NDArray[complex, :, :, :]&lt;/tt&gt;, we end up with &lt;tt class="docutils literal"&gt;(Array, Sized, T0, complex,
(Array, Sized, T1, complex, T1))&lt;/tt&gt; which actually means &lt;em&gt;an array of complex
with at least two dimensions&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="testing-the-brew"&gt;
&lt;h2&gt;Testing the Brew&lt;/h2&gt;
&lt;p&gt;Let's be honest: the &lt;tt class="docutils literal"&gt;tog&lt;/tt&gt; type system is more the result of tinkering than
great research. Type systems is a complex field and I did my best to apply what
I learned during my bibliography on the subject, but it still falls short in
various places. So instead of a formal proof, here is some testing results :-).&lt;/p&gt;
&lt;p&gt;First, the whole test suite passes without much modifications. It helped
to spot a few &lt;em&gt;errors&lt;/em&gt; in the tests, mostly code that was incorrect with
respect to option types. We also updated the way we specify tests input type to rely on PEP484. A typical Pythran unit-test now looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_shadow_import2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run_test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;def shadow_import2(s):&lt;/span&gt;
&lt;span class="sd"&gt;               for set in s : set.add(1)&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;},{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;}],&lt;/span&gt;
        &lt;span class="n"&gt;shadow_import2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;]]]&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where the &lt;tt class="docutils literal"&gt;List[Set[int]]&lt;/tt&gt; expression describes the type for which the code
must be instantiated.&lt;/p&gt;
&lt;p&gt;The following code sample is adapted from the &lt;a class="reference external" href="http://www.mypy-lang.org/examples.html"&gt;MyPy example page&lt;/a&gt;. It requires a type comment to be
correctly typed, while Pythran correctly type checks it without annotation.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="c1"&gt;# Use list comprehension&lt;/span&gt;
    &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;freq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;freq&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()]&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we turn the &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; into &lt;tt class="docutils literal"&gt;&amp;quot;1&amp;quot;&lt;/tt&gt;, we get the following error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;wc.py
CRITICAL&lt;span class="w"&gt; &lt;/span&gt;You&lt;span class="w"&gt; &lt;/span&gt;shall&lt;span class="w"&gt; &lt;/span&gt;not&lt;span class="w"&gt; &lt;/span&gt;pass!
E:&lt;span class="w"&gt; &lt;/span&gt;Invalid&lt;span class="w"&gt; &lt;/span&gt;operand&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;+&lt;span class="sb"&gt;`&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;int&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;and&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;str&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;wc.py,&lt;span class="w"&gt; &lt;/span&gt;line&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And if we remove the &lt;tt class="docutils literal"&gt;0&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;d.get(word)&lt;/tt&gt; may return &lt;tt class="docutils literal"&gt;None&lt;/tt&gt; and the error message becomes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;wc.py
CRITICAL&lt;span class="w"&gt; &lt;/span&gt;You&lt;span class="w"&gt; &lt;/span&gt;shall&lt;span class="w"&gt; &lt;/span&gt;not&lt;span class="w"&gt; &lt;/span&gt;pass!
E:&lt;span class="w"&gt; &lt;/span&gt;Invalid&lt;span class="w"&gt; &lt;/span&gt;operand&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;+&lt;span class="sb"&gt;`&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;Option&lt;span class="o"&gt;[&lt;/span&gt;T0&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;and&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;int&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;wc.py,&lt;span class="w"&gt; &lt;/span&gt;line&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Great!&lt;/p&gt;
&lt;p&gt;Considering Numpy functions, we don't model all of them in tog, but we can
still detect several interesting errors. For instance on a gaussian kernel
(&lt;a class="reference external" href="http://stats.stackexchange.com/questions/15798/how-to-calculate-a-gaussian-kernel-effectively-in-numpy"&gt;error-safe version from stackexchange&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;vectorized_RBF_kernel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sigma&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;X2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;multiply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# sum colums of the matrix&lt;/span&gt;
    &lt;span class="n"&gt;K0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;X2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;
    &lt;span class="n"&gt;K&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;power&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;sigma&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;K0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;K&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;badcall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;vectorized_RBF_kernel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pythran correctly catches the error on &lt;tt class="docutils literal"&gt;vectorized_RBF_kernel&lt;/tt&gt; call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;gaussian.py
CRITICAL&lt;span class="w"&gt; &lt;/span&gt;You&lt;span class="w"&gt; &lt;/span&gt;shall&lt;span class="w"&gt; &lt;/span&gt;not&lt;span class="w"&gt; &lt;/span&gt;pass!
E:&lt;span class="w"&gt; &lt;/span&gt;Invalid&lt;span class="w"&gt; &lt;/span&gt;argument&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;function&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;call&lt;span class="w"&gt; &lt;/span&gt;to&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;Callable&lt;span class="o"&gt;[[&lt;/span&gt;int,&lt;span class="w"&gt; &lt;/span&gt;T3&lt;span class="o"&gt;]&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;tried&lt;span class="w"&gt; &lt;/span&gt;Callable&lt;span class="o"&gt;[[&lt;/span&gt;Array&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;d+,&lt;span class="w"&gt; &lt;/span&gt;T0&lt;span class="o"&gt;]&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;T1&lt;span class="o"&gt;]&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;Array&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;d+,&lt;span class="w"&gt; &lt;/span&gt;T2&lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;gaussian.py,&lt;span class="w"&gt; &lt;/span&gt;line&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;9&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I'm still not satisfied with the tog engine: it's relatively slow, not as
accurate as I'd like it to be, and it's just a type checker: another (simpler)
type engine is used to generate the actual C++ code. That's a lot of not very
enthusiastic concluding remarks, but... I'm French :-)&lt;/p&gt;
&lt;p&gt;On the good side, I happened to learn a &lt;em&gt;lot&lt;/em&gt; about typing and about Python, while
developing this. And Pythran is in a much better shape now, much more usable,
easier to maintain too, so that was worth the effort :-)&lt;/p&gt;
&lt;div class="section" id="acknowledgments"&gt;
&lt;h3&gt;Acknowledgments&lt;/h3&gt;
&lt;p&gt;As usual, I'd like to thanks Pierrick Brunet for all his help. He keeps feeding
me with relevant insights, criticisms and great ideas. Thanks to &lt;a class="reference external" href="http://opendreamkit.org/"&gt;OpenDreamKit&lt;/a&gt; for sponsoring that work, and in particular to
&lt;a class="reference external" href="http://www.logilab.fr/"&gt;Logilab&lt;/a&gt; for their support. Thanks to Lancelot Six,
w1gz and Nicolas M. Thiéry for proof reading this post too :-)&lt;/p&gt;
&lt;p&gt;And last, I'm in debt to all Pythran users for keeping the motivation high!&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[0]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;That could be more actually, for instance to distinguish single
precision float from double prcesion float, the &lt;tt class="docutils literal"&gt;float32&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;float64&lt;/tt&gt;
from numpy. But four types is enough for the envisonned type checking.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The OOP style in C++ is not enforced by the Standard Library as much as it is in the Java SDK though.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="compilation"></category></entry><entry><title>Identifier Binding Computation</title><link href="http://serge-sans-paille.github.io/pythran-stories/identifier-binding-computation.html" rel="alternate"></link><published>2016-04-18T00:00:00+02:00</published><updated>2016-04-18T00:00:00+02:00</updated><author><name>serge-sans-paille</name></author><id>tag:serge-sans-paille.github.io,2016-04-18:/pythran-stories/identifier-binding-computation.html</id><summary type="html">&lt;p class="first last"&gt;Alias analysis is a poor term to describe the processing done by
Pythran that is going to be described here. It could rather be named
&lt;em&gt;static computation of identifier binding&lt;/em&gt;, in the sense that it
tries to give an over-approximation of which values an identifier can
be bound to, at a given point of the program execution. Still,
whatever its name, the process plays a key role in Pythran, so let's
have a look to its internals.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="foreword"&gt;
&lt;h2&gt;Foreword&lt;/h2&gt;
&lt;p&gt;This is &lt;strong&gt;not&lt;/strong&gt; a &lt;a class="reference external" href="http://jupyter-notebook-beginner-guide.readthedocs.org/en/latest/what_is_jupyter.html"&gt;Jupyter notebook&lt;/a&gt;,
but it could have been. Instead, the content of this article is mostly taken from
the &lt;a class="reference external" href="https://docs.python.org/2/library/doctest.html"&gt;Doctest&lt;/a&gt; of the
&lt;tt class="docutils literal"&gt;pythran.analyses.aliases&lt;/tt&gt; module, and the relevant unit tests in
&lt;tt class="docutils literal"&gt;test_typing.py&lt;/tt&gt;. So the reader still has a strong warranty that the output
described is the one she would get by running the commands herself.&lt;/p&gt;
&lt;p&gt;The curious reader can verify this statement by running &lt;tt class="docutils literal"&gt;python &lt;span class="pre"&gt;-m&lt;/span&gt; doctest&lt;/tt&gt;
with Pythran in its &lt;tt class="docutils literal"&gt;PYTHONPATH&lt;/tt&gt; &lt;a class="citation-reference" href="#git-version" id="citation-reference-1"&gt;[git-version]&lt;/a&gt; on the article source, which is in fact what
I did before posting it &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;:-)&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="static-computation-of-identifier-binding"&gt;
&lt;h2&gt;Static Computation of Identifier Binding&lt;/h2&gt;
&lt;p&gt;In Python, everything is a reference, from literal to objects. Assignment
creates a &lt;em&gt;binding&lt;/em&gt; between a reference and an identifier, thus the following
sequence always hold:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="go"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In  some sense, assignement creates aliasing between identifiers, as any change
made to the &lt;em&gt;value&lt;/em&gt; referenced by the identifier &lt;tt class="docutils literal"&gt;b&lt;/tt&gt; impacts the &lt;em&gt;value&lt;/em&gt;
referenced by identifer &lt;tt class="docutils literal"&gt;c&lt;/tt&gt; (and &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;d&lt;/tt&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="go"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the context of Pythran, the static knowledge of the different values of an
identifier &lt;strong&gt;may&lt;/strong&gt; be bound to, is critical. First there is no reason to trust
an identifier, as shown by the following code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="go"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nothing prevents this to happen in Python &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[0]&lt;/a&gt;, so Pythran takes great care in
not confusing &lt;em&gt;identifiers&lt;/em&gt; and &lt;em&gt;values&lt;/em&gt;. And The ill-named Alias Analysis is
the tool we use to solve this problem. In the particular case above, this
analysis tells us that the identifier &lt;tt class="docutils literal"&gt;id&lt;/tt&gt; in the call expression &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;id([1])&lt;/span&gt;&lt;/tt&gt;
always has the value &lt;tt class="docutils literal"&gt;__builtin__.len&lt;/tt&gt;. This can be used, for instance, to
state that this call has no side effect.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="where-is-identifier-binding-used-in-pythran"&gt;
&lt;h2&gt;Where is Identifier Binding Used in Pythran&lt;/h2&gt;
&lt;p&gt;Identifier binding is used by all Pythran analyses that interact with function
calls, when they need to know something about the function property, or when
they want to verify that all the possibles (function) values taken by an
identifier share the same property. For instance:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Conversion from calls with named arguments to call without named arguments, as in &lt;tt class="docutils literal"&gt;zeros(10, dtype=int)&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;Conversion from iterator to generator, e.g. turning &lt;tt class="docutils literal"&gt;range&lt;/tt&gt; into &lt;tt class="docutils literal"&gt;xrange&lt;/tt&gt; (Python2 inside &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;:-/&lt;/span&gt;&lt;/tt&gt;)&lt;/li&gt;
&lt;li&gt;Constant folding (it needs to make sure it manipulates pure functions)&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;But the single more important use of identifier binding is in fact, typing. This
is likely to evolve, but current (clumsy) typing system in Pythran attaches
some kind of typing properties to functions. For instance for the following
function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pythran computes a property that states&lt;/p&gt;
&lt;blockquote&gt;
&amp;gt; if functions &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; is called with an argument of type A as first argument and an argument of type B as second argument,
&amp;gt; &lt;strong&gt;then&lt;/strong&gt; the type of the first argument is the combination of its actual type A and an abstract type &lt;em&gt;Container of B&lt;/em&gt;&lt;/blockquote&gt;
&lt;p&gt;So in case we make the following call:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then the type of &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; is first computed to be &lt;em&gt;empty list&lt;/em&gt; and calling &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;
combines this information with the fact that &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; must be capable of holding
integers, to conclude &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; has the type &lt;em&gt;list of integers&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Identifier binding is used twice in the process. Once to prove that the
&lt;em&gt;identifier&lt;/em&gt; &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; is bound to the value &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt;, and once to track which
values the &lt;em&gt;identifier&lt;/em&gt; &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; was bound to; here to compute that the type
information gathered for &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; also impacts &lt;tt class="docutils literal"&gt;b&lt;/tt&gt;, even if &lt;tt class="docutils literal"&gt;b&lt;/tt&gt; was not used
in the function call, as they share the same value.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="computing-an-overset-of-the-bound-values"&gt;
&lt;h2&gt;Computing an Overset of the Bound Values&lt;/h2&gt;
&lt;p&gt;Pythran &lt;strong&gt;cannot&lt;/strong&gt; track any possible values bound to a variable. In the following example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;identifier &lt;tt class="docutils literal"&gt;i&lt;/tt&gt; can be bound to a great deal of values, and we cannot track them individually.
Instead Pythran only keep tracks of values that are bound to an identifier. All
the others are hidden between the terms of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;lt;unbound-value&amp;gt;&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;So let's start to write some simple equations &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[1]&lt;/a&gt;, with a few test cases demonstrated as Python code which needs some initialization:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;ast&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pythran.analyses.aliases&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pythran&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;passmanager&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;pm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;passmanager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PassManager&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;demo&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, we basically inject the &lt;tt class="docutils literal"&gt;aliases&lt;/tt&gt; namespace into current namespace for
convenience, then create an instance of the object in charge of applying passes
and gathering analysis results.&lt;/p&gt;
&lt;div class="section" id="bool-op-expression"&gt;
&lt;h3&gt;Bool Op Expression&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;(A.k.a ``or`` and ``and``)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Resulting node may alias to either operands:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a, b): return a or b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BoolOp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;(a or b) =&amp;gt; [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code snippet requires a few explanations:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;First, it parses a code snippet and turns it into an Abstract Syntax Tree (AST).&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Second, it computes the alias information at every point of the program.&lt;/dt&gt;
&lt;dd&gt;&lt;tt class="docutils literal"&gt;result&lt;/tt&gt; is a dictionary that maps nodes from the AST to set of
identifiers (remember that for Pythran, a node can only alias to
bounded values. These values are represented by the first identifier
they are bound to).&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Finally, it pretty prints the result of the analysis, using a filter to&lt;/dt&gt;
&lt;dd&gt;only dump the part we are interested in. In that case it dumps a
textual representation of the alias set of the &lt;tt class="docutils literal"&gt;ast.BoolOp&lt;/tt&gt; nodes,
which turns out to be &lt;tt class="docutils literal"&gt;['a', 'b']&lt;/tt&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="unary-operator-expression"&gt;
&lt;h3&gt;Unary Operator Expression&lt;/h3&gt;
&lt;p&gt;Resulting node does not alias to anything&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a): return -a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;UnaryOp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;(- a) =&amp;gt; [&amp;#39;&amp;lt;unbound-value&amp;gt;&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As stated previously, values not bound to an identifier are only represented as &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;lt;unbound-value&amp;gt;&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="if-expression"&gt;
&lt;h3&gt;If Expression&lt;/h3&gt;
&lt;p&gt;Resulting node alias to either branch&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a, b, c): return a if c else b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;IfExp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;(a if c else b) =&amp;gt; [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="dict-expression"&gt;
&lt;h3&gt;Dict Expression&lt;/h3&gt;
&lt;p&gt;A dict is abstracted as an unordered container of its values&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a, b): return {0: a, 1: b}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Dict&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;{0: a, 1: b} =&amp;gt; [&amp;#39;|a|&amp;#39;, &amp;#39;|b|&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where the &lt;tt class="docutils literal"&gt;|id|&lt;/tt&gt; notation means something that may contain &lt;tt class="docutils literal"&gt;id&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="set-expression"&gt;
&lt;h3&gt;Set Expression&lt;/h3&gt;
&lt;p&gt;A set is abstracted as an unordered container of its elements&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a, b): return {a, b}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;{a, b} =&amp;gt; [&amp;#39;|a|&amp;#39;, &amp;#39;|b|&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="tuple-expression"&gt;
&lt;h3&gt;Tuple Expression&lt;/h3&gt;
&lt;p&gt;A tuple is abstracted as an ordered container of its values&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a, b): return a, b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Tuple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;(a, b) =&amp;gt; [&amp;#39;|[0]=a|&amp;#39;, &amp;#39;|[1]=b|&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;|[i]=id|&lt;/span&gt;&lt;/tt&gt; notation means something that
may contain &lt;tt class="docutils literal"&gt;id&lt;/tt&gt; at index &lt;tt class="docutils literal"&gt;i&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="call-expression"&gt;
&lt;h3&gt;Call Expression&lt;/h3&gt;
&lt;p&gt;Resulting node alias to the return_alias of called function,
if the function is already known by Pythran (i.e. it's an Intrinsic)
or if Pythran already computed it's &lt;tt class="docutils literal"&gt;return_alias&lt;/tt&gt; behavior.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def f(a): return a&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def foo(b): c = f(b)&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;f&lt;/tt&gt; function create aliasing between
the returned value and its first argument.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Call&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;f(b) =&amp;gt; [&amp;#39;b&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This also works with intrinsics, e.g. &lt;tt class="docutils literal"&gt;dict.setdefault&lt;/tt&gt; which
may create alias between its third argument and the return value.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;def foo(a, d): __builtin__.dict.setdefault(d, 0, a)&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Call&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;__builtin__.dict.setdefault(d, 0, a) =&amp;gt; [&amp;#39;&amp;lt;unbound-value&amp;gt;&amp;#39;, &amp;#39;a&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that complex cases can arise, when one of the formal parameter
is already known to alias to various values:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def f(a, b): return a and b&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def foo(A, B, C, D): return f(A or B, C or D)&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Call&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;f((A or B), (C or D)) =&amp;gt; [&amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;D&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="subscript-expression"&gt;
&lt;h3&gt;Subscript Expression&lt;/h3&gt;
&lt;p&gt;The resulting node alias only stores the subscript relationship if we don't know
anything about the subscripted node.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a): return a[0]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Subscript&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;a[0] =&amp;gt; [&amp;#39;a[0]&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we know something about the container, e.g. in case of a list, we
can use this information to get more accurate informations:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a, b, c): return [a, b][c]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Subscript&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;[a, b][c] =&amp;gt; [&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Moreover, in case of a tuple indexed by a constant value, we can
further refine the aliasing information:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def f(a, b): return a, b&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def foo(a, b): return f(a, b)[0]&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Subscript&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;f(a, b)[0] =&amp;gt; [&amp;#39;a&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nothing is done for slices, even if the indices are known :-/&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class="doctest-block"&gt;
&amp;gt;&amp;gt;&amp;gt; module = ast.parse('def foo(a, b, c): return [a, b, c][1:]')
&amp;gt;&amp;gt;&amp;gt; result = pm.gather(Aliases, module)
&amp;gt;&amp;gt;&amp;gt; Aliases.dump(result, filter=ast.Subscript)
[a, b, c][1:] =&amp;gt; ['&amp;lt;unbound-value&amp;gt;']
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="list-comprehension"&gt;
&lt;h3&gt;List Comprehension&lt;/h3&gt;
&lt;p&gt;A comprehension is not abstracted in any way&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a, b): return [a for i in b]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ListComp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;[a for i in b] =&amp;gt; [&amp;#39;&amp;lt;unbound-value&amp;gt;&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="return-statement"&gt;
&lt;h3&gt;Return Statement&lt;/h3&gt;
&lt;p&gt;A side effect of computing aliases on a Return is that it updates the
&lt;tt class="docutils literal"&gt;return_alias&lt;/tt&gt; field of current function&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a, b): return a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;return_alias&lt;/span&gt; &lt;span class="c1"&gt;# doctest: +ELLIPSIS&lt;/span&gt;
&lt;span class="go"&gt;&amp;lt;function merge_return_aliases at...&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This field is a function that takes as many nodes as the function
argument count as input and returns an expression based on
these arguments if the function happens to create aliasing
between its input and output. In our case:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;return_alias&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Load&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Num&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;span class="go"&gt;[&amp;#39;A&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This also works if the relationship between input and output
is more complex:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a, b): return a or b[0]&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;return_alias&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;L0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Load&lt;/span&gt;&lt;span class="p"&gt;())],&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Load&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Load&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;
&lt;span class="go"&gt;[&amp;#39;B&amp;#39;, &amp;#39;[L0][0]&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which actually means that when called with two arguments &lt;tt class="docutils literal"&gt;B&lt;/tt&gt; and
the single-element list &lt;tt class="docutils literal"&gt;[L[0]]&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;foo&lt;/tt&gt; may returns either the
first argument, or the first element of the second argument.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="assign-statement"&gt;
&lt;h3&gt;Assign Statement&lt;/h3&gt;
&lt;p&gt;Assignment creates aliasing between lhs and rhs&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;def foo(a): c = a ; d = e = c ; {c, d, e}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;{c, d, e} =&amp;gt; [&amp;#39;|a|&amp;#39;, &amp;#39;|a|&amp;#39;, &amp;#39;|a|&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Everyone points to the formal parameter &lt;tt class="docutils literal"&gt;a&lt;/tt&gt; o/&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="for-statement"&gt;
&lt;h3&gt;For Statement&lt;/h3&gt;
&lt;p&gt;For loop creates aliasing between the target
and the content of the iterator&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def foo(a):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;   for i in a:&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;       &lt;/span&gt;&lt;span class="si"&gt;{i}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;{i} =&amp;gt; [&amp;#39;|i|&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not very useful, unless we know something about the iterated container&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def foo(a, b):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;    for i in [a, b]:&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;          &lt;/span&gt;&lt;span class="si"&gt;{i}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;{i} =&amp;gt; [&amp;#39;|a|&amp;#39;, &amp;#39;|b|&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="if-statement"&gt;
&lt;h3&gt;If Statement&lt;/h3&gt;
&lt;p&gt;After an if statement, the values from both branches are merged,
potentially creating more aliasing:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def foo(a, b):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;    if a: c=a&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;    else: c=b&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;    return &lt;/span&gt;&lt;span class="si"&gt;{c}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gather&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;Aliases&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Set&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;{c} =&amp;gt; [&amp;#39;|a|&amp;#39;, &amp;#39;|b|&amp;#39;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="illustration-typing"&gt;
&lt;h3&gt;Illustration: Typing&lt;/h3&gt;
&lt;p&gt;Thanks to the above analysis, Pythran is capable of computing some rather difficult informations! In the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;typing_aliasing_and_variable_subscript_combiner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
       &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extend&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pythran knows that &lt;tt class="docutils literal"&gt;b&lt;/tt&gt; is a list of elements of the same type as &lt;tt class="docutils literal"&gt;i&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;And in the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;typing_and_function_dict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;funcs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;zero&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="s1"&gt;&amp;#39;one&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;funcs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pythran knows that &lt;tt class="docutils literal"&gt;s&lt;/tt&gt; is a set of integers :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="illustration-dead-code-elimination"&gt;
&lt;h3&gt;Illustration: Dead Code Elimination&lt;/h3&gt;
&lt;p&gt;Consider the following sequence:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def useless0(x): return x + 1&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def useless1(x): return x - 1&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;def useful(i):&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;    funcs = useless0, useless1&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;    funcs[i%2](i)&lt;/span&gt;
&lt;span class="gp"&gt;... &lt;/span&gt;&lt;span class="s1"&gt;    return i&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pythran can prove that both &lt;tt class="docutils literal"&gt;useless0&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;useless1&lt;/tt&gt; don't have side
effects. Thanks to the binded value analysis, it can also prove that
&lt;strong&gt;whatever&lt;/strong&gt; the index, &lt;tt class="docutils literal"&gt;funcs[something]&lt;/tt&gt; either points to &lt;tt class="docutils literal"&gt;useless0&lt;/tt&gt; or
&lt;tt class="docutils literal"&gt;useless1&lt;/tt&gt;. And in either cases, the function has no side effect, which means
we can remove the whole instruction:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pythran.optimizations&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;DeadCodeElimination&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pythran.backend&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Python&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ast&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;DeadCodeElimination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;pm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Python&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;def useless0(x):&lt;/span&gt;
&lt;span class="go"&gt;    return (x + 1)&lt;/span&gt;
&lt;span class="go"&gt;def useless1(x):&lt;/span&gt;
&lt;span class="go"&gt;    return (x - 1)&lt;/span&gt;
&lt;span class="go"&gt;def useful(i):&lt;/span&gt;
&lt;span class="go"&gt;    funcs = (useless0, useless1)&lt;/span&gt;
&lt;span class="go"&gt;    pass&lt;/span&gt;
&lt;span class="go"&gt;    return i&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Other optimizations will take care of removing the useless  assignment to &lt;tt class="docutils literal"&gt;funcs&lt;/tt&gt; :-)&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="acknowledgments"&gt;
&lt;h2&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;Thanks a lot to Pierrick Brunet for his careful review, and to Florent Cayré from &lt;a class="reference external" href="https://www.logilab.fr/"&gt;Logilab&lt;/a&gt; for his advices that helped &lt;strong&gt;a lot&lt;/strong&gt; to improve the post. And of course to &lt;a class="reference external" href="http://opendreamkit.org/"&gt;OpenDreamKit&lt;/a&gt; for funding this work!&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[0]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Except the sanity of the developer, but who never used the &lt;tt class="docutils literal"&gt;id&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;len&lt;/tt&gt; identifiers?&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Starting from this note, the identifiers from the &lt;a class="reference external" href="https://docs.python.org/2/library/ast.html"&gt;ast&lt;/a&gt; module are used.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="git-version" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#citation-reference-1"&gt;[git-version]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;The Pythran commit id used for this article is &lt;tt class="docutils literal"&gt;f38a16491ea644fbaed15e8facbcabf869637b39&lt;/tt&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="compilation"></category></entry><entry><title>Compiler Flags</title><link href="http://serge-sans-paille.github.io/pythran-stories/compiler-flags.html" rel="alternate"></link><published>2016-03-29T00:00:00+02:00</published><updated>2016-03-29T00:00:00+02:00</updated><author><name>serge-sans-paille</name></author><id>tag:serge-sans-paille.github.io,2016-03-29:/pythran-stories/compiler-flags.html</id><summary type="html">&lt;p class="first last"&gt;Playing with compiler forwarded by Pythran to GCC (or Clang) can yield surprising results, let's explore this!&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="when-size-matters"&gt;
&lt;h2&gt;When Size Matters&lt;/h2&gt;
&lt;p&gt;Everything started a few days ago with a Pythran user complaining about the
size of the binaries generated by Pythran. In essence, take the following code
&lt;cite&gt;cda.py&lt;/cite&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#pythran export closest_distance_arrays(float, float, float[], float[])&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;closest_distance_arrays&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lat1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;long1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;latitudes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;longitudes&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;degrees_to_radians&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;180.0&lt;/span&gt;
    &lt;span class="n"&gt;phi1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;90.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;lat1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;degrees_to_radians&lt;/span&gt;
    &lt;span class="n"&gt;phi2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;90.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;latitudes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;degrees_to_radians&lt;/span&gt;
    &lt;span class="n"&gt;theta1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;long1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;degrees_to_radians&lt;/span&gt;
    &lt;span class="n"&gt;theta2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;longitudes&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;degrees_to_radians&lt;/span&gt;
    &lt;span class="n"&gt;cos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phi1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phi2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theta1&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;theta2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
           &lt;span class="n"&gt;math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phi1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phi2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;arc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arccos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argmin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arc&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;arc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It doesn't even weight a kilobyte, and when benchmarked, it runs in a few milliseconds:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;-s&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;import numpy as np; n = 20000 ; lat, lon = np.random.rand(n), np.random.rand(n); x,y = np.random.rand(), np.random.rand(); from cda import closest_distance_arrays&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;closest_distance_arrays(x,y,lat, lon)&amp;#39;&lt;/span&gt;
&lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;loops,&lt;span class="w"&gt; &lt;/span&gt;best&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.95&lt;span class="w"&gt; &lt;/span&gt;msec&lt;span class="w"&gt; &lt;/span&gt;per&lt;span class="w"&gt; &lt;/span&gt;loop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thanks to the &lt;tt class="docutils literal"&gt;#pythran export&lt;/tt&gt; annotation, Pythran can turn it into a native
library that runs slightly faster than the Python version:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;cda.py
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;-s&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;import numpy as np; n = 20000 ; lat, lon = np.random.rand(n), np.random.rand(n); x,y = np.random.rand(), np.random.rand(); from cda import closest_distance_arrays&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;closest_distance_arrays(x,y,lat, lon)&amp;#39;&lt;/span&gt;
&lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;loops,&lt;span class="w"&gt; &lt;/span&gt;best&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.17&lt;span class="w"&gt; &lt;/span&gt;msec&lt;span class="w"&gt; &lt;/span&gt;per&lt;span class="w"&gt; &lt;/span&gt;loop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is, however, a very big binary:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;ls&lt;span class="w"&gt; &lt;/span&gt;-lh&lt;span class="w"&gt; &lt;/span&gt;cda.so
-rwxr-xr-x&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sguelton&lt;span class="w"&gt; &lt;/span&gt;sguelton&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.3M&lt;span class="w"&gt; &lt;/span&gt;Mar&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;29&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;18&lt;/span&gt;:10&lt;span class="w"&gt; &lt;/span&gt;cda.so*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Who wants to multiply the binary size by &lt;tt class="docutils literal"&gt;2e3&lt;/tt&gt; to get less than a &lt;tt class="docutils literal"&gt;x2&lt;/tt&gt; speedup?&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-culprits-debug-informations"&gt;
&lt;h2&gt;The culprits: Debug Informations&lt;/h2&gt;
&lt;p&gt;One can call Pythran with the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-v&lt;/span&gt;&lt;/tt&gt; flag to inspect part of its internal,
especially the C++ compiler call done to perform object code generation and
linking:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;cda.py&lt;span class="w"&gt; &lt;/span&gt;-v
running&lt;span class="w"&gt; &lt;/span&gt;build_ext
running&lt;span class="w"&gt; &lt;/span&gt;build_src
build_src
building&lt;span class="w"&gt; &lt;/span&gt;extension&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;cda&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sources
build_src:&lt;span class="w"&gt; &lt;/span&gt;building&lt;span class="w"&gt; &lt;/span&gt;npy-pkg&lt;span class="w"&gt; &lt;/span&gt;config&lt;span class="w"&gt; &lt;/span&gt;files
new_compiler&lt;span class="w"&gt; &lt;/span&gt;returns&lt;span class="w"&gt; &lt;/span&gt;distutils.unixccompiler.UnixCCompiler
INFO&lt;span class="w"&gt;     &lt;/span&gt;customize&lt;span class="w"&gt; &lt;/span&gt;UnixCCompiler
customize&lt;span class="w"&gt; &lt;/span&gt;UnixCCompiler&lt;span class="w"&gt; &lt;/span&gt;using&lt;span class="w"&gt; &lt;/span&gt;build_ext
********************************************************************************
distutils.unixccompiler.UnixCCompiler
&lt;span class="nv"&gt;linker_exe&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gcc&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;compiler_so&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gcc&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-DNDEBUG&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-g&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-fwrapv&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-O2&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wall&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wstrict-prototypes&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-fno-strict-aliasing&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-g&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-O2&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-fPIC&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;archiver&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;x86_64-linux-gnu-gcc-ar&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;rc&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;preprocessor&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gcc&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-E&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;linker_so&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;x86_64-linux-gnu-gcc&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-pthread&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-shared&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wl,-O1&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wl,-Bsymbolic-functions&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wl,-z,relro&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-fno-strict-aliasing&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-DNDEBUG&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-g&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-fwrapv&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-O2&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wall&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wstrict-prototypes&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wdate-time&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-D_FORTIFY_SOURCE=2&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-g&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-fstack-protector-strong&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wformat&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Werror=format-security&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wl,-z,relro&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-g&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-O2&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;compiler_cxx&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;g++&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;ranlib&lt;/span&gt;&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;None
&lt;span class="nv"&gt;compiler&lt;/span&gt;&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gcc&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-DNDEBUG&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-g&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-fwrapv&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-O2&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wall&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-Wstrict-prototypes&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-fno-strict-aliasing&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-g&amp;#39;&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;-O2&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="nv"&gt;libraries&lt;/span&gt;&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;
&lt;span class="nv"&gt;library_dirs&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt;
&lt;span class="nv"&gt;include_dirs&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/usr/include/python2.7&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
INFO&lt;span class="w"&gt;     &lt;/span&gt;Generated&lt;span class="w"&gt; &lt;/span&gt;module:&lt;span class="w"&gt; &lt;/span&gt;cda
INFO&lt;span class="w"&gt;     &lt;/span&gt;Output:&lt;span class="w"&gt; &lt;/span&gt;/home/sguelton/sources/pythran/cda.so
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That's a pretty long trace, but that's what verbose mode is for. The
enlightened reader noticed that we use &lt;tt class="docutils literal"&gt;distutils&lt;/tt&gt; under the hood to abstract
the compiler calls, and that's why we're getting some funky compiler flags like
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-g&lt;/span&gt; &lt;span class="pre"&gt;-fwrapv&lt;/span&gt; &lt;span class="pre"&gt;-O2&lt;/span&gt; &lt;span class="pre"&gt;-Wall&lt;/span&gt; &lt;span class="pre"&gt;-fno-strict-aliasing&lt;/span&gt; &lt;span class="pre"&gt;-g&lt;/span&gt; &lt;span class="pre"&gt;-O2&lt;/span&gt; &lt;span class="pre"&gt;-fPIC&lt;/span&gt;&lt;/tt&gt; or even funkier
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-fstack-protector-strong&lt;/span&gt; &lt;span class="pre"&gt;-Wformat&lt;/span&gt; &lt;span class="pre"&gt;-Werror=format-security&lt;/span&gt; &lt;span class="pre"&gt;-Wl,-z,relro&lt;/span&gt;&lt;/tt&gt;.
That's the default for native python extensions on my distrib. Funny enough the
last ones are hardening flags used to improve the security of the binary and I
wrote a (passionating) article about it for Quarkslab &lt;a class="footnote-reference" href="#footnote-1" id="footnote-reference-1"&gt;[0]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It turns out &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-g&lt;/span&gt;&lt;/tt&gt; (and C++) is responsible for the fat binary: if we simply
strip the binary, we get back to a decent size:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;strip&lt;span class="w"&gt; &lt;/span&gt;cda.so
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;ls&lt;span class="w"&gt; &lt;/span&gt;-lh&lt;span class="w"&gt; &lt;/span&gt;cda.so
-rwxr-xr-x&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sguelton&lt;span class="w"&gt; &lt;/span&gt;sguelton&lt;span class="w"&gt; &lt;/span&gt;151K&lt;span class="w"&gt; &lt;/span&gt;Mar&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;29&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;18&lt;/span&gt;:26&lt;span class="w"&gt; &lt;/span&gt;cda.so
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As Pythran users generally don't want the debug info on the generated native
code, we chose to strip them by default, using the linker flag
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-Wl,-strip-all&lt;/span&gt;&lt;/tt&gt; that removes all symbol informations, including debug
symbols.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-step-further-default-symbol-visibility"&gt;
&lt;h2&gt;A Step further: Default Symbol visibility&lt;/h2&gt;
&lt;p&gt;While we're at it, let's call &lt;tt class="docutils literal"&gt;nm&lt;/tt&gt; to check if any symbol remains in the
binary. After all, the Python interpreter still needs some of them to load the
native extension!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;nm&lt;span class="w"&gt; &lt;/span&gt;-C&lt;span class="w"&gt; &lt;/span&gt;-D&lt;span class="w"&gt; &lt;/span&gt;cda.so
&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;skipping&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;900&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;entries
000000000001ed00&lt;span class="w"&gt; &lt;/span&gt;u&lt;span class="w"&gt; &lt;/span&gt;nt2::ext::implement&amp;lt;nt2::tag::rem_pio2_&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;boost::dispatch::meta::scalar_&amp;lt;boost::dispatch::meta::double_&amp;lt;double&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;,&lt;span class="w"&gt; &lt;/span&gt;boost::dispatch::meta::scalar_&amp;lt;boost::dispatch::meta::double_&amp;lt;double&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;,&lt;span class="w"&gt; &lt;/span&gt;boost::dispatch::meta::scalar_&amp;lt;boost::dispatch::meta::double_&amp;lt;double&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;boost::dispatch::tag::cpu_,&lt;span class="w"&gt; &lt;/span&gt;void&amp;gt;::__kernel_rem_pio2&lt;span class="o"&gt;(&lt;/span&gt;double*,&lt;span class="w"&gt; &lt;/span&gt;double*,&lt;span class="w"&gt; &lt;/span&gt;int,&lt;span class="w"&gt; &lt;/span&gt;int,&lt;span class="w"&gt; &lt;/span&gt;int,&lt;span class="w"&gt; &lt;/span&gt;int&lt;span class="w"&gt; &lt;/span&gt;const*&lt;span class="o"&gt;)&lt;/span&gt;::PIo2
000000000001edc0&lt;span class="w"&gt; &lt;/span&gt;u&lt;span class="w"&gt; &lt;/span&gt;nt2::ext::implement&amp;lt;nt2::tag::rem_pio2_&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;boost::dispatch::meta::scalar_&amp;lt;boost::dispatch::meta::double_&amp;lt;double&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;,&lt;span class="w"&gt; &lt;/span&gt;boost::dispatch::meta::scalar_&amp;lt;boost::dispatch::meta::double_&amp;lt;double&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;,&lt;span class="w"&gt; &lt;/span&gt;boost::dispatch::meta::scalar_&amp;lt;boost::dispatch::meta::double_&amp;lt;double&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;boost::dispatch::tag::cpu_,&lt;span class="w"&gt; &lt;/span&gt;void&amp;gt;::__ieee754_rem_pio2&lt;span class="o"&gt;(&lt;/span&gt;double,&lt;span class="w"&gt; &lt;/span&gt;double*&lt;span class="o"&gt;)&lt;/span&gt;::two_over_pi
000000000001ed40&lt;span class="w"&gt; &lt;/span&gt;u&lt;span class="w"&gt; &lt;/span&gt;nt2::ext::implement&amp;lt;nt2::tag::rem_pio2_&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;boost::dispatch::meta::scalar_&amp;lt;boost::dispatch::meta::double_&amp;lt;double&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;,&lt;span class="w"&gt; &lt;/span&gt;boost::dispatch::meta::scalar_&amp;lt;boost::dispatch::meta::double_&amp;lt;double&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;,&lt;span class="w"&gt; &lt;/span&gt;boost::dispatch::meta::scalar_&amp;lt;boost::dispatch::meta::double_&amp;lt;double&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;,&lt;span class="w"&gt; &lt;/span&gt;boost::dispatch::tag::cpu_,&lt;span class="w"&gt; &lt;/span&gt;void&amp;gt;::__ieee754_rem_pio2&lt;span class="o"&gt;(&lt;/span&gt;double,&lt;span class="w"&gt; &lt;/span&gt;double*&lt;span class="o"&gt;)&lt;/span&gt;::npio2_hw
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I can tell you Python is &lt;em&gt;not&lt;/em&gt; using nt2 dispatch mechanism to load native
extensions. Again, the default compiler settings are responsible for this
noise, and the relevant compiler flag is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-fvisibility=hidden&lt;/span&gt;&lt;/tt&gt; that tells the
compiler than only the functions flagged with a special attribute are part of
the external ABI, the other ones are not exported. As Python uses a single
entry point to load Pythran modules, namely &lt;tt class="docutils literal"&gt;PyInit_cda&lt;/tt&gt; for Python3 modules
and &lt;tt class="docutils literal"&gt;initcda&lt;/tt&gt; for Python2 modules &lt;a class="footnote-reference" href="#footnote-2" id="footnote-reference-2"&gt;[1]&lt;/a&gt;, one can add the &lt;tt class="docutils literal"&gt;__attribute__
&lt;span class="pre"&gt;((visibility(&amp;quot;default&amp;quot;)))&lt;/span&gt;&lt;/tt&gt; on this symbol and it will be the only exported
one. This slightly impacts the code size, may decrease loading time and
eventually gives the compiler more optimization opportunities, but nothing
significant there (131K), apart the pleasure of generating cleaner binaries.
That's also going to be the default for next Pythran version.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="out-of-chance-getting-faster-binaries"&gt;
&lt;h2&gt;Out of chance: getting faster binaries&lt;/h2&gt;
&lt;p&gt;In the (huge) info pages of GCC, near the doc of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-fvisibility=hidden&lt;/span&gt;&lt;/tt&gt;,
there's this (GCC only) compiler flag, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-fwhole-program&lt;/span&gt;&lt;/tt&gt; that implements some
kind of Link Time Optimization, in the sense that it tells the compiler to
consider the current compilation unit (or code) as a whole program. As
specified in the GCC man page, &amp;quot;All public functions and variables with the
exception of &amp;quot;main&amp;quot; and those merged by attribute &amp;quot;externally_visible&amp;quot; become
static functions and in effect are optimized more aggressively by
interprocedural optimizers.&amp;quot;, which basically means that every function is
considered static except for &amp;quot;main&amp;quot; and the ones that are explicitly told not
to be.  This allows the compiler for instance to remove functions that are
always inlined, and thus win space. So we flag the &lt;tt class="docutils literal"&gt;initcda&lt;/tt&gt; function with
&lt;tt class="docutils literal"&gt;__attribute__ ((externally_visible))&lt;/tt&gt;. That sounds a bit redundant to me
with the visibility attribute, but it turns out this triggers abunch of
different optimization path that gives us a significantly smaller binary, that
runs slightly faster:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;cda.py&lt;span class="w"&gt; &lt;/span&gt;-fvisibility&lt;span class="o"&gt;=&lt;/span&gt;hidden&lt;span class="w"&gt; &lt;/span&gt;-fwhole-program&lt;span class="w"&gt; &lt;/span&gt;-Wl,-strip-all
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;ls&lt;span class="w"&gt; &lt;/span&gt;-lh&lt;span class="w"&gt; &lt;/span&gt;cda.so
-rwxr-xr-x&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;sguelton&lt;span class="w"&gt; &lt;/span&gt;sguelton&lt;span class="w"&gt; &lt;/span&gt;31K&lt;span class="w"&gt; &lt;/span&gt;Mar&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;29&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;18&lt;/span&gt;:52&lt;span class="w"&gt; &lt;/span&gt;cda.so*
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;-s&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;import numpy as np; n = 20000 ; lat, lon = np.random.rand(n), np.random.rand(n); x,y = np.random.rand(), np.random.rand(); from cda import closest_distance_arrays&amp;#39;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;closest_distance_arrays(x,y,lat, lon)&amp;#39;&lt;/span&gt;
&lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;loops,&lt;span class="w"&gt; &lt;/span&gt;best&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.15&lt;span class="w"&gt; &lt;/span&gt;msec&lt;span class="w"&gt; &lt;/span&gt;per&lt;span class="w"&gt; &lt;/span&gt;loop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All these flags are now the default on Linux.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="playing-with-the-optimization-flags-too"&gt;
&lt;h2&gt;Playing with the optimization flags too&lt;/h2&gt;
&lt;p&gt;The default optimization flag is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O2&lt;/span&gt;&lt;/tt&gt;, and that's generally a decent choice.
On &lt;tt class="docutils literal"&gt;cda.py&lt;/tt&gt;, using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt; does not give much change (gcc 4.9):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;cda.py&lt;span class="w"&gt; &lt;/span&gt;-fvisibility&lt;span class="o"&gt;=&lt;/span&gt;hidden&lt;span class="w"&gt; &lt;/span&gt;-fwhole-program&lt;span class="w"&gt; &lt;/span&gt;-Wl,-strip-all&lt;span class="w"&gt; &lt;/span&gt;-O3
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;loops,&lt;span class="w"&gt; &lt;/span&gt;best&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.14&lt;span class="w"&gt; &lt;/span&gt;msec&lt;span class="w"&gt; &lt;/span&gt;per&lt;span class="w"&gt; &lt;/span&gt;loop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Asking for code specific to my CPU using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-march=native&lt;/span&gt;&lt;/tt&gt; actually gives some improvments&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;cda.py&lt;span class="w"&gt; &lt;/span&gt;-fvisibility&lt;span class="o"&gt;=&lt;/span&gt;hidden&lt;span class="w"&gt; &lt;/span&gt;-fwhole-program&lt;span class="w"&gt; &lt;/span&gt;-Wl,-strip-all&lt;span class="w"&gt; &lt;/span&gt;-O3&lt;span class="w"&gt; &lt;/span&gt;-march&lt;span class="o"&gt;=&lt;/span&gt;native
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;loops,&lt;span class="w"&gt; &lt;/span&gt;best&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.11&lt;span class="w"&gt; &lt;/span&gt;msec&lt;span class="w"&gt; &lt;/span&gt;per&lt;span class="w"&gt; &lt;/span&gt;loop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But the best speedup has a price: relaxing standard compliance with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-Ofast&lt;/span&gt;&lt;/tt&gt;
can be beneficial if you're not using denormalized numbers, infinity and the
monstrosity that lies with &lt;tt class="docutils literal"&gt;NaN&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;cda.py&lt;span class="w"&gt; &lt;/span&gt;-fvisibility&lt;span class="o"&gt;=&lt;/span&gt;hidden&lt;span class="w"&gt; &lt;/span&gt;-fwhole-program&lt;span class="w"&gt; &lt;/span&gt;-Wl,-strip-all&lt;span class="w"&gt; &lt;/span&gt;-Ofast&lt;span class="w"&gt; &lt;/span&gt;-march&lt;span class="o"&gt;=&lt;/span&gt;native
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;loops,&lt;span class="w"&gt; &lt;/span&gt;best&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.02&lt;span class="w"&gt; &lt;/span&gt;msec&lt;span class="w"&gt; &lt;/span&gt;per&lt;span class="w"&gt; &lt;/span&gt;loop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you're really into compiler flags tuning, you can try out &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-funroll-loops&lt;/span&gt;&lt;/tt&gt;
or try to tune the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-finline-limit=N&lt;/span&gt;&lt;/tt&gt; parameter (that actually get mets dow
to &lt;tt class="docutils literal"&gt;1ms per loop&lt;/tt&gt;) but that's going a bit too far :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="don-t-forget-vectorization"&gt;
&lt;h2&gt;Don't forget Vectorization&lt;/h2&gt;
&lt;p&gt;Combining &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O3&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-march=native&lt;/span&gt;&lt;/tt&gt; triggers compiler auto-vectorization[2]_,
but that did not helped much on our case. Indeed, automatic vectorization, as
in « I am using the multimedia instruction set of my CPU » is still a difficult
task for compilers. Fortunately Pythran helps here, and passing the
not-so-experimental-anymore-but-still-not-default flag &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-DUSE_BOOST_SIMD&lt;/span&gt;&lt;/tt&gt;
triggers some hard-coded vectorization based on &lt;tt class="docutils literal"&gt;boost.simd&lt;/tt&gt; &lt;a class="footnote-reference" href="#footnote-4" id="footnote-reference-3"&gt;[3]&lt;/a&gt;, and that
&lt;strong&gt;did&lt;/strong&gt; help:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c1"&gt;# esod mumixam&lt;/span&gt;
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;pythran.run&lt;span class="w"&gt; &lt;/span&gt;cda.cpp&lt;span class="w"&gt; &lt;/span&gt;-fvisibility&lt;span class="o"&gt;=&lt;/span&gt;hidden&lt;span class="w"&gt; &lt;/span&gt;-fwhole-program&lt;span class="w"&gt; &lt;/span&gt;-Wl,-strip-all&lt;span class="w"&gt; &lt;/span&gt;-Ofast&lt;span class="w"&gt; &lt;/span&gt;-march&lt;span class="o"&gt;=&lt;/span&gt;native&lt;span class="w"&gt; &lt;/span&gt;-funroll-loops&lt;span class="w"&gt; &lt;/span&gt;-finline-limit&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;100000000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-DUSE_BOOST_SIMD
&amp;gt;&lt;span class="w"&gt; &lt;/span&gt;python&lt;span class="w"&gt; &lt;/span&gt;-m&lt;span class="w"&gt; &lt;/span&gt;timeit&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="m"&gt;1000&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;loops,&lt;span class="w"&gt; &lt;/span&gt;best&lt;span class="w"&gt; &lt;/span&gt;of&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;462&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;usec&lt;span class="w"&gt; &lt;/span&gt;per&lt;span class="w"&gt; &lt;/span&gt;loo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that's woth 63 kilobytes :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="concluding-remarks"&gt;
&lt;h2&gt;Concluding Remarks&lt;/h2&gt;
&lt;p&gt;Source-to-source compilers &lt;em&gt;do&lt;/em&gt; generate ugly intermediate code, and Pythran is
not an exception. One benefit though is that you can get a full control over
the &lt;em&gt;backend&lt;/em&gt; compiler, which means you can tune it to your needs. Given some
knowledge and benchmarking effort, it can get you closer to your goal without
changing the original code.&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-1" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-1"&gt;[0]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;And I am shamelessly advertising it :-) &lt;a class="reference external" href="http://blog.quarkslab.com/clang-hardening-cheat-sheet.html"&gt;http://blog.quarkslab.com/clang-hardening-cheat-sheet.html&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-2" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-2"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;If you really want to inspect the intermediate C++ code generated by pythran use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-E&lt;/span&gt;&lt;/tt&gt; flag and a &lt;tt class="docutils literal"&gt;cda.cpp&lt;/tt&gt; will be generated.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-3" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[2]&lt;/td&gt;&lt;td&gt;only GCC needs this, clang turns vectorisation at &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-O2&lt;/span&gt;&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-march=native&lt;/span&gt;&lt;/tt&gt; allows it to use a more recent instruction set if available.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="footnote-4" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#footnote-reference-3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Thanks Numscale &lt;a class="reference external" href="https://www.numscale.com/boost-simd/"&gt;https://www.numscale.com/boost-simd/&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</content><category term="compilation"></category></entry></feed>