<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Pythran stories - examples</title><link href="http://serge-sans-paille.github.io/pythran-stories/" rel="alternate"></link><link href="http://serge-sans-paille.github.io/pythran-stories/feeds/examples.atom.xml" rel="self"></link><id>http://serge-sans-paille.github.io/pythran-stories/</id><updated>2021-08-19T00:00:00+02:00</updated><entry><title>GSoC’21 Improve performance through the use of Pythran</title><link href="http://serge-sans-paille.github.io/pythran-stories/gsoc21-improve-performance-through-the-use-of-pythran.html" rel="alternate"></link><published>2021-08-19T00:00:00+02:00</published><updated>2021-08-19T00:00:00+02:00</updated><author><name>Xingyu Liu</name></author><id>tag:serge-sans-paille.github.io,2021-08-19:/pythran-stories/gsoc21-improve-performance-through-the-use-of-pythran.html</id><summary type="html">&lt;p class="first last"&gt;This project is about using Pythran to accelerate algorithms in SciPy and
writing benchmarks for the algorithms. Let's look into the details of the project.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="project-overview"&gt;
&lt;h2&gt;Project Overview&lt;/h2&gt;
&lt;p&gt;There are a lot of algorithms in &lt;a class="reference external" href="https://github.com/scipy/scipy"&gt;SciPy&lt;/a&gt; that use &lt;a class="reference external" href="https://github.com/cython/cython"&gt;Cython&lt;/a&gt; to improve
the performance of code that would be too slow as pure Python,
e.g. algorithms in &lt;tt class="docutils literal"&gt;scipy.spatial&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;scipy.stats&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;scipy.optimize&lt;/tt&gt;.
Recently, SciPy added experimental support for &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran"&gt;Pythran&lt;/a&gt;,
to make it easier to accelerate Python code.
Compared with Cython, Pythran is more readable and even faster.
Furthermore, SciPy uses &lt;a class="reference external" href="https://asv.readthedocs.io/"&gt;Airspeed Velocity&lt;/a&gt; for performance benchmarking.
Therefore, our project includes:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Writing benchmarks for the algorithms in SciPy&lt;/li&gt;
&lt;li&gt;Accelerating SciPy algorithms with Pythran.&lt;/li&gt;
&lt;li&gt;Find and solve potential issues in Pythran&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;My full proposal can be accessed &lt;a class="reference external" href="https://docs.google.com/document/d/1nM7dYbmModiukQw-sSOVGz6t5S6HC0VVWucYadI_aMQ/edit?usp=sharing"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-i-have-done"&gt;
&lt;h2&gt;What I have done&lt;/h2&gt;
&lt;div class="section" id="pull-requests"&gt;
&lt;h3&gt;Pull Requests&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SciPy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In SciPy, I mainly worked on writing benchmarks to measure the performance
of algorithms and using Pythran to accelerate those algorithms. Also, I
looked into the public open issues now and then and helped fix them.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="benchmark" src="https://img.shields.io/badge/benchmark-F9E79F" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14018"&gt;BENCH: add benchmark for f_oneway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="benchmark" src="https://img.shields.io/badge/benchmark-F9E79F" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14163"&gt;BENCH: add benchmark for energy_distance and wasserstein_distance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="benchmark" src="https://img.shields.io/badge/benchmark-F9E79F" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14228#"&gt;BENCH: add more benchmarks for inferential statistics tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="benchmark" src="https://img.shields.io/badge/benchmark-F9E79F" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14224#"&gt;MAINT: Modify to use new random API in benchmarks&lt;/a&gt;: Most of current benchmarks uses &lt;tt class="docutils literal"&gt;np.random.seed()&lt;/tt&gt;, but it is recommended to use &lt;tt class="docutils literal"&gt;np.random.default_rng()&lt;/tt&gt; instead.&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="benchmark" src="https://img.shields.io/badge/benchmark-F9E79F" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy"&gt;BENCH: add benchmark for somersd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="accelerate" src="https://img.shields.io/badge/accelerate-A9DFBF" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14308"&gt;ENH: use Pythran to speedup somersd and _tau_b&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="bug" src="https://img.shields.io/badge/bug-5D6D7E" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14458"&gt;DOC: clarify meaning of rvalue in stats.linregress&lt;/a&gt; : helped fix a bug and review the PR.&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="bug" src="https://img.shields.io/badge/bug-5D6D7E" /&gt; &lt;img alt="Under Review" src="https://img.shields.io/badge/UnderReview-2ea44f" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14338"&gt;BUG: fix stats.binned_statistic_dd issue with values close to bin edge&lt;/a&gt; : helped fix a bug.&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="accelerate" src="https://img.shields.io/badge/accelerate-A9DFBF" /&gt; &lt;img alt="Under Review" src="https://img.shields.io/badge/UnderReview-2ea44f" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/13957"&gt;ENH: Pythran implementation of _compute_prob_outside_square and _compute_prob_inside_method to speedup stats.ks_2samp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="accelerate" src="https://img.shields.io/badge/accelerate-A9DFBF" /&gt; &lt;img alt="Under Review" src="https://img.shields.io/badge/UnderReview-2ea44f" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14345"&gt;ENH: improved binned_statistic_dd via Pythran&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="accelerate" src="https://img.shields.io/badge/accelerate-A9DFBF" /&gt; &lt;img alt="Under Review" src="https://img.shields.io/badge/UnderReview-2ea44f" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14429"&gt;ENH: improve cspline1d, qspline1d, and relative funcs via Pythran&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="accelerate" src="https://img.shields.io/badge/accelerate-A9DFBF" /&gt; &lt;img alt="Under Review" src="https://img.shields.io/badge/UnderReview-2ea44f" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14430"&gt;ENH: improve siegelslopes via pythran&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="accelerate" src="https://img.shields.io/badge/accelerate-A9DFBF" /&gt; &lt;img alt="On Hold" src="https://img.shields.io/badge/OnHold-F5B7B1" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14154"&gt;ENH: Pythran implementation of _cdf_distance&lt;/a&gt; : Pythran version is slightly better than the Python one after fixing &lt;tt class="docutils literal"&gt;np.searchsorted()&lt;/tt&gt;. When SciPy begin using SIMD in the future, it may be faster so this PR is currently on hold.&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="accelerate" src="https://img.shields.io/badge/accelerate-A9DFBF" /&gt; &lt;img alt="On Hold" src="https://img.shields.io/badge/OnHold-F5B7B1" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14314"&gt;WIP: ENH: improve _count_paths_outside_method via pythran&lt;/a&gt; : This PR got stuck in a Mac specific error and we haven’t find out why.&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="accelerate" src="https://img.shields.io/badge/accelerate-A9DFBF" /&gt; &lt;img alt="On Hold" src="https://img.shields.io/badge/OnHold-F5B7B1" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14376"&gt;WIP: ENH: improve sort_vertices_of_regions via Pythran and made it more readable&lt;/a&gt; : There are currently two tests we can’t pass because 1. With Pythran we can’t do inplace sort 2. The input type will change in the Pythran function&lt;/li&gt;
&lt;li&gt;&lt;img alt="SciPy" src="https://img.shields.io/badge/SciPy-1F618D" /&gt; &lt;img alt="accelerate" src="https://img.shields.io/badge/accelerate-A9DFBF" /&gt; &lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14473"&gt;ENH: improve _sosfilt_float via Pythran&lt;/a&gt;  : &lt;tt class="docutils literal"&gt;_sosfilt_float&lt;/tt&gt; is already implemented in Cython. We were considering to replace it but found Pythran performance is not much better than Cython's, and Pythran does not support &lt;tt class="docutils literal"&gt;object&lt;/tt&gt; type, so we decided not to merge it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Pythran&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When using Pythran to improve SciPy algorithms, I found some important modules are not
supported or got false result in Pythran currently, e.g. boolean arguments
such as &lt;tt class="docutils literal"&gt;keepdims&lt;/tt&gt; were not supported in Pythran because the return type
would change based on the value of &lt;tt class="docutils literal"&gt;keepdims&lt;/tt&gt; (True or False). Therefore, I made a general
support for such cases.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;img alt="Pythran" src="https://img.shields.io/badge/Pythran-EC7063" /&gt; &lt;img alt="feature" src="https://img.shields.io/badge/feature-F5CBA7" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/pull/1830"&gt;Import test cases from scipy&lt;/a&gt; : Import Pythran functions in SciPy as test case in Pythran&lt;/li&gt;
&lt;li&gt;&lt;img alt="Pythran" src="https://img.shields.io/badge/Pythran-EC7063" /&gt; &lt;img alt="feature" src="https://img.shields.io/badge/feature-F5CBA7" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/pull/1869#"&gt;Feature/add keep dims&lt;/a&gt; : support keepdims argument in &lt;tt class="docutils literal"&gt;np.mean()&lt;/tt&gt; in Pythran&lt;/li&gt;
&lt;li&gt;&lt;img alt="Pythran" src="https://img.shields.io/badge/Pythran-EC7063" /&gt; &lt;img alt="feature" src="https://img.shields.io/badge/feature-F5CBA7" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/pull/1876"&gt;Support boolean arguments in numpy unique&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Pythran" src="https://img.shields.io/badge/Pythran-EC7063" /&gt; &lt;img alt="feature" src="https://img.shields.io/badge/feature-F5CBA7" /&gt; &lt;img alt="Merged" src="https://img.shields.io/badge/Merged-76448A" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/pull/1878"&gt;General implementation of supporting immediate arguments&lt;/a&gt;: Generalize the above two solutions to support immediate arguments.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="issues"&gt;
&lt;h3&gt;Issues&lt;/h3&gt;
&lt;p&gt;In addition to the above-mentioned issues, I dug up more issues in Pythran while
using it, so I opened many issues in Pythran. My mentors often helped solve
those issues and then I tested whether the fixes worked.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1793"&gt;Pythran makes np.searchsorted much slower&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1753"&gt;Pythran may make a function slower?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1792"&gt;u_values[u_sorter].searchsort would cause &amp;quot;Function path is chained attributes and name&amp;quot; but np.search would not&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1791"&gt;all_values.sort() would cause compilation error but np.sort(all_values) would not&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1792"&gt;u_values[u_sorter].searchsort would cause &amp;quot;Function path is chained attributes and name&amp;quot; but np.searchsort would not&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1804"&gt;Support scipy.special.binom?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1815"&gt;Got AttributeError: module 'scipy' has no attribute 'special' when building scipy with special import&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1818"&gt;Got compilation error when the inner variable type changes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1819"&gt;Can't index an 2d array like a1[int, tuple]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1820"&gt;keep_dims is not supported in np.mean()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Closed" src="https://img.shields.io/badge/Closed-A6ACAF" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1850"&gt;can't use np.expand_dims with specified keyword argument&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Open" src="https://img.shields.io/badge/Open-2ea44f" /&gt; &lt;a class="reference external" href="https://github.com/scipy/scipy/issues/14315"&gt;bus error on Mac but works fine on Linux for _count_paths_outside_method pythran version&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;img alt="Open" src="https://img.shields.io/badge/Open-2ea44f" /&gt; &lt;a class="reference external" href="https://github.com/serge-sans-paille/pythran/issues/1858"&gt;array assignment res[cond1] = ax[cond1] works fine for int[] or float[] or float[:,:] but not int[:,:]&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="work-left"&gt;
&lt;h2&gt;Work Left&lt;/h2&gt;
&lt;p&gt;As the project proceeded, I found it was difficult to find
suitable algorithms to be implemented. A suitable algorithm for Pythran should meet at least three requirements:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;It is currently slow.&lt;/li&gt;
&lt;li&gt;It does not have modules that Pythran doesn't support, e.g. class type, imported SciPy modules.&lt;/li&gt;
&lt;li&gt;It has obvious loops so that the speedup would be large.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I looked through almost all the algorithms but found little.
Moreover, in our past experience
with Pythran, we often run into some things that are easy to get wrong, such as
using arrays that are views as input to a Pythranized function, or the use of different dtypes.
Therefore, we need better testing and we decided to change the plan to
write better testing infrastructure for Pythran extensions:
&lt;a class="reference external" href="https://github.com/scipy/scipy/pull/14559#"&gt;WIP: TST: add tests for Pythran somersd&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="project-experience"&gt;
&lt;h2&gt;Project Experience&lt;/h2&gt;
&lt;p&gt;It has been a great experience working on this project in GSoC'21,
my mentors are really friendly and responsive,
and the community are also always willing to help.&lt;/p&gt;
&lt;p&gt;Special thanks to my mentors, Ralf and Serge, who provided immense support
for me to get through the difficulties.
I’m very fortunate to get the chance to dive into and contribute to SciPy
and Pythran this summer, especially with such awesome mentors.
I have learnt a lot, both intellectually and spiritually. I would love to continue contributing to SciPy and Pythran in the future :)&lt;/p&gt;
&lt;p&gt;Thanks to Google Summer of Code and the Python Software Foundation!&lt;/p&gt;
&lt;/div&gt;
</content><category term="examples"></category></entry><entry><title>Pythran as a bridge between fast prototyping and code deployment</title><link href="http://serge-sans-paille.github.io/pythran-stories/pythran-as-a-bridge-between-fast-prototyping-and-code-deployment.html" rel="alternate"></link><published>2018-11-28T00:00:00+01:00</published><updated>2018-11-28T00:00:00+01:00</updated><author><name>Jean Laroche</name></author><id>tag:serge-sans-paille.github.io,2018-11-28:/pythran-stories/pythran-as-a-bridge-between-fast-prototyping-and-code-deployment.html</id><summary type="html">&lt;p class="first last"&gt;How pythran can be use to bridge the divide between fast prototyping and code deployment&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;As a researcher/engineer (really, an algorithm developer) in the general area of audio and speech processing, I've always run into the same difficulty at all the companies I've worked at: How to quickly prototype and develop algorithms, and subsequently turn them into efficient code that can be deployed to customers.&lt;/p&gt;
&lt;p&gt;These have always been incompatible goals: For rapid prototyping, over many years, I've used Matlab, then Python with Numpy. Both are wonderful in the level of mathematical abstraction they provide (for example, 1 line to multiply a matrix by a vector), and they're very useful for testing and debugging as they're interpreted and provide a full array of plotting routines for inspecting what's going on in your algorithm. For example, you can put a breakpoint in your program, and when it stops, you can start poking around, executing high-level commands, etc.&lt;/p&gt;
&lt;p&gt;But when came time to deploy the prototype algorithm, we typically had to bite the bullet and rewrite it in C or C++: For one thing, it was not possible or practical to ship Matlab or Numpy to our customers so our prototype code could be run in their environment. It was also crucial to squeeze every drop of efficiency out of the processor, and predictability and reproducibility of performance was also very important! When processing real-time audio, you cannot wait around for garbage collection to terminate because you will run out of audio samples to play. So interpreted languages were pretty much out.&lt;/p&gt;
&lt;p&gt;This means we had teams of people porting the Matlab or Python code to C++, creating test vectors to ensure results were similar enough, and henceforth maintaining the C++ code to ensure that it still matched the Matlab/Python reference code. This was an enormous overhead, but one that was still preferable to prototyping in C/C++. In some of the companies I worked at, we tested various tools to convert Matlab to C++ but none of them were truly satisfactory (most of them required you to severely constrain the way you coded so the conversion code could run).&lt;/p&gt;
&lt;p&gt;Then I discovered Pythran. Unlike Cython and Numba, Pythran not only accelerates your Python code (by compiling modules into fast .so files) but Pythran also generates self-contained C++ code that implements your Python/Numpy algorithm. The C++ code is fully portable, does not require any Python or Numpy libraries, does not rely at all on Python, and can easily be incorporated into a C++ project. Once compiled, you prototype code becomes extremely efficient, optimized for the target architecture, and its performance is predictable and reproducible. What's more, you do not need to change anything to your Python code to make it work with Pythran, provided that you're using supported functions and features, so you can keep your prototype code as your reference, update and improve it, and re-generate the fast C++ version with a single command. No need to maintain and synchronize two versions of the same code.&lt;/p&gt;
&lt;p&gt;To me, this is nothing short of a revolution in how I do my work. To show you the new workflow I use, I've take an example of a moderately complicated audio algorithm written in Python. With this blog post, you'll be able to see how simple it is to convert the high-level Python/Numpy code into a fully deployable, fast, C++ version.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="an-example-time-scaling-an-audio-file"&gt;
&lt;h2&gt;An example: time-scaling an audio file&lt;/h2&gt;
&lt;div class="section" id="a-note-on-time-scaling"&gt;
&lt;h3&gt;A note on time-scaling&lt;/h3&gt;
&lt;p&gt;Time scaling in audio signal processing refers to slowing down or speeding up an audio recording while preserving its original pitch (frequency). You may be familiar with playing back a record or a tape at half its normal speed: this both slows down the music but it also changes the pitch: for example a singer's voice become completely unnatural, a female singer might start sounding more like a male. Instead of the music being in a certain key, say A major, it will play in a different key (E major for example), if speeding up by a factor 1.5x. This is undesirable and many techniques have been developed to allow controlling the playback speed while preserving the original tone of the music.&lt;/p&gt;
&lt;p&gt;Time-scaling is useful for example if you're trying to figure out a fast series of notes in an improvisation for example, or if you're learning a language and want hear a speaker at a slower speed...&lt;/p&gt;
&lt;p&gt;Some time-scaling technique operates in the &amp;quot;frequency domain&amp;quot;, i.e. using a Fourier transform to get a view of which frequencies are present in the music at any given time. The one I chose in this blog post is a frequency domain technique that's both simple, and achieves reasonable quality for most (but definitely not all) audio tracks and is described in the paper &amp;quot;Improved  Phase  Vocoder
Time-Scale  Modification  of  Audio&amp;quot; IEEE  TRANSACTIONS  ON SPEECH  AND  AUDIO  PROCESSING, VOL.  7,  NO.  3,  MAY  1999. See for example: &lt;a class="reference external" href="http://www.cs.bu.edu/fac/snyder/cs591/Literature%20and%20Resources/ImprovedPhaseVocoderTimeScaleMod.pdf"&gt;Paper&lt;/a&gt;. If you're interested in the general area of audio time-scaling, the Wikipedia &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Audio_time_stretching_and_pitch_scaling"&gt;entry&lt;/a&gt; is a very good introduction.&lt;/p&gt;
&lt;p&gt;The technique uses a Fast Fourier Transform (FFT), pick peaking to locate pure tones in the audio, and complex rotations to adjust the phase of the Fourier transom prior to reconstructing the audio signal.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="python-numpy-code"&gt;
&lt;h3&gt;Python/Numpy code&lt;/h3&gt;
&lt;p&gt;The code is shown below. Refer to the paper if you're interested in the &amp;quot;theoretical&amp;quot; explanation for what's being done. As you can see, the Numpy implementation is simple but not trivial, requiring several steps. Note that the algorithm uses both real and complex numbers: the output of the rfft routine is a complex array, and the rotations are complex numbers. Copy the code below into a &lt;tt class="docutils literal"&gt;time_scaling.py&lt;/tt&gt; file.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hanning&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;([])&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;computeRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rotations&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fftSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;inputHop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;outputHop&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Compute the appropriate rotations based on input and output hop.&lt;/span&gt;
    &lt;span class="n"&gt;AX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;# Find peaks in AX: values that are larger than their two neighbors on the left and on the right&lt;/span&gt;
    &lt;span class="n"&gt;peaks&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nonzero&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;AX&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;AX&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AX&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;AX&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AX&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;AX&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AX&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;AX&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:]))[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;ii&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peaks&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# Compute new rotation.&lt;/span&gt;
        &lt;span class="n"&gt;rot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;fftSize&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outputHop&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;inputHop&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="c1"&gt;# Cumulate rotation with the one from the previous frame.&lt;/span&gt;
        &lt;span class="n"&gt;rotations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="n"&gt;rot&lt;/span&gt;
        &lt;span class="c1"&gt;# Now spread this rotation to all the neighboring bins (half-way between peaks).&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ii&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;.5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peaks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ii&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ii&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peaks&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;.5&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;peaks&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ii&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;rotations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rotations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rotations&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;sRate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;factor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Process parameters.&lt;/span&gt;
    &lt;span class="n"&gt;windowLengthS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.060&lt;/span&gt;
    &lt;span class="n"&gt;windowHopS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.030&lt;/span&gt;

    &lt;span class="n"&gt;windowLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;round&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;windowLengthS&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sRate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;windowHop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;round&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;windowHopS&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sRate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;fftSize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ceil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="n"&gt;window&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hanning&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;halfWinLen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;floor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="n"&gt;curInSamp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;curOutSamp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;prevInSamp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curInSamp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;windowHop&lt;/span&gt;
    &lt;span class="c1"&gt;# Initialize rotations. They&amp;#39;re complex, and they&amp;#39;re the same for all channels.&lt;/span&gt;
    &lt;span class="n"&gt;rotations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ones&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fftSize&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;complex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;outSig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;factor&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;&lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dtype&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;xx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zeros&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fftSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;curInSamp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;curOutSamp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outSig&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="c1"&gt;# Take the fft of the signal starting at curInSamp. It&amp;#39;s a good thing to have a zero-phase fft so roll it by&lt;/span&gt;
        &lt;span class="c1"&gt;# half a window size so the middle of the input window is at t=0&lt;/span&gt;
        &lt;span class="n"&gt;xx&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;curInSamp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;curInSamp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt;
        &lt;span class="n"&gt;xx&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="n"&gt;xx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;roll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;halfWinLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rfft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fftSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# Compute required rotations based on the input and output hop.&lt;/span&gt;
        &lt;span class="n"&gt;computeRotation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;rotations&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fftSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;curInSamp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;prevInSamp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;windowHop&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# Apply to FFT&lt;/span&gt;
        &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;rotations&lt;/span&gt;
        &lt;span class="c1"&gt;# Take the inverse FFT, undo the circular roll and overlap add into the output signal.&lt;/span&gt;
        &lt;span class="n"&gt;yy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fft&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;irfft&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fftSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;yy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;roll&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;yy&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;halfWinLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;outSig&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;curOutSamp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;curOutSamp&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;yy&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;windowLength&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt;
        &lt;span class="c1"&gt;# Increment the output sample by half a window size, and the input sample according to the time scaling factor.&lt;/span&gt;
        &lt;span class="n"&gt;prevInSamp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curInSamp&lt;/span&gt;
        &lt;span class="n"&gt;curOutSamp&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;windowHop&lt;/span&gt;
        &lt;span class="n"&gt;curInSamp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;round&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curOutSamp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;outSig&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can run the process function on an audio file. For simplicity I'm using a &lt;tt class="docutils literal"&gt;.wav&lt;/tt&gt; file: Scipy has a very simple interface for reading or writing a &lt;tt class="docutils literal"&gt;.wav&lt;/tt&gt; file.
Note that our process function expects a 1D input array. If you open a stereo &lt;tt class="docutils literal"&gt;.wav&lt;/tt&gt; file, the array returned by wavfile.read will be 2D. In case this happens I'm only keeping the left channel. You can copy paste the following code into a &lt;tt class="docutils literal"&gt;main.py&lt;/tt&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time_scaling&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;scipy.io&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wavfile&lt;/span&gt;

&lt;span class="n"&gt;sRate&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wavfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;r&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/Users/jlaroche/temp/MessageInABottleMono.wav&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[:,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ndim&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;
&lt;span class="n"&gt;factor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.2&lt;/span&gt;
&lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time_scaling&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;astype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;32767&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sRate&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;wavfile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;./out.wav&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;sRate&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="mi"&gt;32767&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;astype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;int16&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You should be able to open the output file and listen to it in any program that plays wavfiles (for example afplay on macos).&lt;/p&gt;
&lt;p&gt;Let's time the function in IPython. For this you start IPython (install it if you don't have it, it's a great complement to Python)).
In Ipython, you can simply put &lt;tt class="docutils literal"&gt;%timeit&lt;/tt&gt; in front of the line you'd like to benchmark:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;timeit&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;time_scaling&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;astype&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;32767&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sRate&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;factor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the (quite long) wav file I was using, %timeit returned&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
1 loop, best of 3: 15.1 s per loop
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="using-pythran"&gt;
&lt;h3&gt;Using Pythran&lt;/h3&gt;
&lt;p&gt;To be able to use the process function from the module that Pythran will create, we need to export it to Python. This is what the following &lt;tt class="docutils literal"&gt;#pythran export&lt;/tt&gt; directive does. This can be placed anywhere in the .py file.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#pythran export process(float[] or float[::],float,float)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the first parameter is declared as &lt;tt class="docutils literal"&gt;float[] or &lt;span class="pre"&gt;float[::]&lt;/span&gt;&lt;/tt&gt; a simple float Numpy array or a view into a float Numpy array. The two remaining parameters are declared as float and it will be crucial to pass them as floats when calling process.&lt;/p&gt;
&lt;p&gt;Now simply run&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pythran&lt;/span&gt; &lt;span class="n"&gt;time_scaling&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A time_scaling.so file is created.
Now the same &lt;tt class="docutils literal"&gt;main.py&lt;/tt&gt; code will execute much faster because import time_scaling will now import a compiled, very efficient &lt;tt class="docutils literal"&gt;.so&lt;/tt&gt; file.&lt;/p&gt;
&lt;p&gt;For the same file as above, &lt;tt class="docutils literal"&gt;%timeit&lt;/tt&gt; now returns:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
1 loop, best of 3: 1.87 s per loop
&lt;/pre&gt;
&lt;p&gt;The speed up is amazing. The function runs about 8 times faster than it did in pure Python/Numpy.
Note that if you pass an int instead of a float to the process function &lt;tt class="docutils literal"&gt;time_scaling.process(x.astype(float) / 32767, int(sRate), factor)&lt;/tt&gt; you will get a run-time error so make sure you're passing the very same types you've declared in time_scaling.py.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="calling-from-c"&gt;
&lt;h3&gt;Calling from C++&lt;/h3&gt;
&lt;p&gt;As I explained above, one of the most amazing aspects of Pythran is that it generates self contained C++ code that can be called from any other C++ program. As I explained, the code is self contained in that it does not require any dlls, and makes no call to the Python library. In short, it's a very efficient C++ version of your Python/Numpy algorithm, fully portable to any target architecture.
To create a c++ version of our process function, we simply do:&lt;/p&gt;
&lt;pre class="code shell literal-block"&gt;
pythran&lt;span class="w"&gt; &lt;/span&gt;-e&lt;span class="w"&gt; &lt;/span&gt;time_scaling.py
&lt;/pre&gt;
&lt;p&gt;This creates a file time_scaling.cpp that can then be compiled along with the calling code. Note that in this case, the &lt;tt class="docutils literal"&gt;#pythran export&lt;/tt&gt; declaration is no longer needed. You can take a look at the C++ code, but it will be extremely cryptic and heavily templated... But that's not a problem as this code never need to be hand-tweaked.&lt;/p&gt;
&lt;p&gt;Now, how do we call this &lt;tt class="docutils literal"&gt;process()&lt;/tt&gt; function from our main C++ program?
For this, we must pass the audio in a Numpy like array, but the Pythran C++ source code provides convenient functions to do just that.
This is the main.cpp file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="c1"&gt;      /* printf, scanf, NULL */&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;numpy/_numpyconfig.h&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;time_scaling.cpp&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;pythonic/include/numpy/array.hpp&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;pythonic/numpy/array.hpp&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;pythonic/include/utils/array_helper.hpp&amp;quot;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;quot;pythonic/include/types/ndarray.hpp&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;using&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;namespace&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nn"&gt;pythonic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Helper to create a float 1D array from a pointer&lt;/span&gt;
&lt;span class="k"&gt;template&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;typename&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ndarray&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pshape&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arrayFromBuf1D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pshape&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ndarray&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;pshape&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;shape&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;ownership&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;external&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;#define MAX_NUM_SAMPS 500*44100&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Read audio&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;./police.raw&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;MAX_NUM_SAMPS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;unique_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Read %d samples&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Create array from our buffer&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;inputArray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;arrayFromBuf1D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ptr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Call process:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;chrono&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;system_clock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outputArray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__pythran_time_scaling&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="n"&gt;inputArray&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;44100.&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;1.2f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;chrono&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;system_clock&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Elapsed: %d ms&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;chrono&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;duration_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;chrono&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;milliseconds&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// Now save to a binary float file:&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;FILE&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fdout&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;out.raw&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numSamps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outputArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;//    printf(&amp;quot;NumSamps = %d\n&amp;quot;,numSamps);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;fwrite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outputArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;numSamps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fdout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;fclose&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fdout&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this code, I'm reading a raw file into a float array, and I create a Pythran 1D array from the float buffer.
Note the extra pair of parentheses in the call to process:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outputArray&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__pythran_time_scaling&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="n"&gt;inputArray&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;44100.&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;1.2f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Similary, the process function returns a Numpy array, and the output signal is in the array's buffer. It's pretty straightforward to get the size of the array, and a pointer to its data. The size is obtained with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;numSamps&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;outputArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the pointer to the float data is simply:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;outputArray&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I find it easier to create a Makefile to run Pythran and then the compiler. In installed pythran in a virtual env in &lt;tt class="docutils literal"&gt;$HOME/Dev/PythranTest/MAIN/venv&lt;/tt&gt; so my makefile looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;VENV&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;$$&lt;/span&gt;HOME/Dev/PythranTest/MAIN/venv
&lt;span class="nv"&gt;IDIR1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;VENV&lt;span class="k"&gt;)&lt;/span&gt;/lib/python2.7/site-packages/pythran
&lt;span class="nv"&gt;IDIR2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;VENV&lt;span class="k"&gt;)&lt;/span&gt;/lib/python2.7/site-packages/numpy/core/include
&lt;span class="nv"&gt;IDIR3&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;VENV&lt;span class="k"&gt;)&lt;/span&gt;/include/python2.7
&lt;span class="nv"&gt;OFLAG&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-O2
&lt;span class="nv"&gt;PFLAG&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-DUSE_XSIMD&lt;span class="w"&gt; &lt;/span&gt;-fopenmp

&lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;.&lt;span class="n"&gt;cpp&lt;/span&gt; &lt;span class="n"&gt;time_scaling&lt;/span&gt;.&lt;span class="n"&gt;cpp&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;c++&lt;span class="w"&gt; &lt;/span&gt;-std&lt;span class="o"&gt;=&lt;/span&gt;c++11&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;OFLAG&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-w&lt;span class="w"&gt; &lt;/span&gt;-I&lt;span class="k"&gt;$(&lt;/span&gt;IDIR1&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-I&lt;span class="k"&gt;$(&lt;/span&gt;IDIR2&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-I&lt;span class="k"&gt;$(&lt;/span&gt;IDIR3&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;-undefined&lt;span class="w"&gt; &lt;/span&gt;dynamic_lookup&lt;span class="w"&gt; &lt;/span&gt;-march&lt;span class="o"&gt;=&lt;/span&gt;native&lt;span class="w"&gt; &lt;/span&gt;-F.&lt;span class="w"&gt; &lt;/span&gt;main.cpp&lt;span class="w"&gt; &lt;/span&gt;-o&lt;span class="w"&gt; &lt;/span&gt;main

&lt;span class="nf"&gt;time_scaling.cpp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;time_scaling&lt;/span&gt;.&lt;span class="n"&gt;py&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;@echo&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;\033[0;36mRunning pythran\033[0m&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;pythran&lt;span class="w"&gt; &lt;/span&gt;-e&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;PFLAG&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;time_scaling.py

&lt;span class="nf"&gt;clean&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;rm&lt;span class="w"&gt; &lt;/span&gt;-f&lt;span class="w"&gt; &lt;/span&gt;time_scaling.cpp&lt;span class="w"&gt; &lt;/span&gt;main
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that you can use &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;pythran-config&lt;/span&gt; &lt;span class="pre"&gt;--cflags&lt;/span&gt; &lt;span class="pre"&gt;--libs&lt;/span&gt;&lt;/tt&gt; to find out what include paths are needed in your case. Also note that since I'm not making any call to functions that need blas (linear algebra functions) I do not need to link with the blas libraries so I've omitted it from my makefile.
With this makefile, all you need to do is make main, and Pythran will first be run to create &lt;tt class="docutils literal"&gt;time_scaling.cpp&lt;/tt&gt; then c++ will be called to compile &lt;tt class="docutils literal"&gt;main.cpp&lt;/tt&gt; into &lt;tt class="docutils literal"&gt;main&lt;/tt&gt;. I'm using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-march=native&lt;/span&gt;&lt;/tt&gt; flag for maximum efficiency of the executable.&lt;/p&gt;
&lt;p&gt;Now main is a completely free-standing executable that does not need any library, and is 100% independent from Python or Numpy. You can run it from the console.
It's even faster than the Python/Pythran version: the program reports:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
Read 12436200 samples
Elapsed: 1565 ms
&lt;/pre&gt;
&lt;p&gt;So that's 1.56s down from 1.87s for the Python/Pythran version, a further 15% speed improvement!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="a-final-note-on-time-scaling"&gt;
&lt;h3&gt;A final note on time-scaling&lt;/h3&gt;
&lt;p&gt;The algorithm I used in this blog post achieves good results in many cases, but not in all cases. For one, results are usually better when speeding up rather than slowing down audio. One of the biggest problems with this simple algorithm is that it does not do well when the audio includes sharp transients (for example, drums, percussions, etc). You'll notice that the transients become smeared in time, lose their sharpness. Many improvements have been suggested to alleviate this problem, see for example &lt;a class="reference external" href="http://www.ircam.fr/equipes/analyse-synthese/roebel/paper/dafx2003.pdf"&gt;this paper&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I hope this example will have convinced you. Python/Numpy is a great prototyping language: high-level, flexible, fast enough for rapid prototyping, it has all the features one might want for algorithm prototyping. Now with Pythran you can turn this high-level interpreted code into a blazingly fast C++ version that no longer depends on Python or Numpy, can be included into your C++ project, and compiled to any target you might like. In addition, if the code you're deploying contains some proprietary IP, the translation to C++ and compilation to machine code makes reverse-engineering it far harder than if it was deployed using python, even with obfuscation.&lt;/p&gt;
&lt;p&gt;Pythran has some limitations: you cannot use classes, and polymorphism is limited to some degree. In practice, I find these limitations acceptable (the lack of class support is the one that I find the most cumbersome), given the efficiency of the C++ code that's generated.&lt;/p&gt;
&lt;/div&gt;
</content><category term="examples"></category></entry></feed>