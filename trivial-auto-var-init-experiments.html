<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Pythran stories - Trivial Auto Var Init Experiments</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"/>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.2/css/all.min.css"/>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda"/>
        <link rel="stylesheet" type="text/css" href="./theme/css/main.css"/>
            <link href="http://serge-sans-paille.github.io/pythran-stories/
feeds/all.atom.xml"
                  type="application/atom+xml" rel="alternate" title="Pythran stories Atom Feed"/>

</head>
<body>
<style>.github-corner:hover .octo-arm {
    animation: octocat-wave 560ms ease-in-out
}
@keyframes octocat-wave {
    0%, 100% {
        transform: rotate(0)
    }
    20%, 60% {
        transform: rotate(-25deg)
    }
    40%, 80% {
        transform: rotate(10deg)
    }
}
@media (max-width: 500px) {
    .github-corner:hover .octo-arm {
        animation: none
    }

    .github-corner .octo-arm {
        animation: octocat-wave 560ms ease-in-out
    }
}</style><div id="container">
    <header>
        <h1><a href="./">Pythran stories</a></h1>
            <ul class="social-media">
                    <li><a href="https://github.com/serge-sans-paille/pythran"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a></li>
                    <li><a href="http://serge-sans-paille.github.io/pythran-stories/
feeds/all.atom.xml"
                           type="application/atom+xml" rel="alternate"><i class="fa fa-rss fa-lg"
                                                                          aria-hidden="true"></i></a></li>
            </ul>
        <p><em></em></p>
    </header>
    <nav>
        <ul>
                    <li><a href="./category/benchmark.html"> benchmark </a></li>
                    <li><a href="./category/compilation.html"> compilation </a></li>
                    <li><a href="./category/engineering.html"> engineering </a></li>
                    <li><a href="./category/examples.html"> examples </a></li>
                    <li><a                         class="active" href="./category/mozilla.html"> mozilla </a></li>
                    <li><a href="./category/optimisation.html"> optimisation </a></li>
                    <li><a href="./category/release.html"> release </a></li>
        </ul>
    </nav>
<main>
    <article>
        <h1>Trivial Auto Var Init Experiments</h1>
        
        <aside>
            <ul>
                <li>
                    <time datetime="2023-11-30 00:00:00+01:00">Nov 30, 2023</time>
                </li>
                <li>
                    Categories:
                    <a href="./category/mozilla.html"><em>mozilla</em></a>
                </li>
                </li>
            </ul>
        </aside>
        <p><tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init=[pattern|zero|uninitialized]</span></tt> is a compiler flag that controls how the stack is initialized before any value is initialized to it. The default is <tt class="docutils literal">uninitialized</tt>: no initialization is done, reading from an uninitialized location of the stack yields whatever value lies there at that point. This is Undefined Behavior in both C and C++. It makes stack allocation a <span class="formula"><span class="scriptfont">O</span>(1)</span> operation, which is nice, but it also is (a) a common source of programming errors (b) a potential security issue.</p>
<p>As a countermeasure, the modes <tt class="docutils literal">pattern</tt> and <tt class="docutils literal">zero</tt> have been introduced.
The former sets stack slots to hard-coded patterns, depending on the type
(integral, floating point, pointer…) of the associated stack-allocated
variables, the latter justs sets the stack to zero. Both operation make stack
allocation a  <span class="formula"><span class="scriptfont">O</span>(<i>n</i>)</span> operation. The idea between the two modes is that
setting stack slots to zero is faster, but setting them to a pattern is more
likely to exhibit failing behavior.</p>
<div class="section" id="comparing-the-approach-with-address-sanitizer">
<h2>Comparing the Approach with Address Sanitizer</h2>
<p>Let's consider a very simple program that reads data from <tt class="docutils literal">stdin</tt> and dumps it to
<tt class="docutils literal">stdout</tt>, using a small buffer.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[</span><span class="mi">2048</span><span class="p">];</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">  </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fread</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span><span class="w"> </span><span class="n">stdin</span><span class="p">);</span>
<span class="w">    </span><span class="n">fwrite</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">stdout</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>When compiled with <tt class="docutils literal">clang <span class="pre">-O2</span> <span class="pre">-S</span> <span class="pre">-emit-llvm</span> <span class="pre">-o-</span></tt> the function entry block,
expressed in LLVM IR, is:</p>
<div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="p">[</span><span class="m">2048</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">],</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.lifetime.start.p0</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="m">2048</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">)</span><span class="w"> </span><span class="vg">#3</span>
<span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv nv-Anonymous">%2</span>
</pre></div>
<p>The first instruction allocates memory on the stack, and that's it.</p>
<p>If we compile it with <tt class="docutils literal">clang <span class="pre">-O2</span> <span class="pre">-S</span> <span class="pre">-emit-llvm</span> <span class="pre">-o-</span> <span class="pre">-ftrivial-auto-var-init=zero</span></tt>, the prologue becomes (note the extra <tt class="docutils literal">llvm.memset</tt> to zero):</p>
<div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="p">[</span><span class="m">2048</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">],</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.lifetime.start.p0</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="m">2048</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">)</span><span class="w"> </span><span class="vg">#4</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.memset.p0.i64</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="k">dereferenceable</span><span class="p">(</span><span class="m">2048</span><span class="p">)</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">2048</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">),</span><span class="w"> </span><span class="nv">!annotation</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span>
<span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv nv-Anonymous">%2</span>
</pre></div>
<p>When passing <tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init=pattern</span></tt> we keep the <tt class="docutils literal">llvm.memset</tt>,
but zero has been turned into a pattern (<tt class="docutils literal">0xAA</tt>):</p>
<div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="p">[</span><span class="m">2048</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">],</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.lifetime.start.p0</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="m">2048</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">)</span><span class="w"> </span><span class="vg">#4</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.memset.p0.i64</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="k">dereferenceable</span><span class="p">(</span><span class="m">2048</span><span class="p">)</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">-86</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">2048</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">),</span><span class="w"> </span><span class="nv">!annotation</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span>
<span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv nv-Anonymous">%2</span>
</pre></div>
<p>In both cases, the <tt class="docutils literal">llvm.memset</tt> call is annotated with some metadata that
help tracking its origin.</p>
<div class="highlight"><pre><span></span><span class="nv nv-Anonymous">!3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">!{</span><span class="nv">!&quot;auto-init&quot;</span><span class="p">}</span>
</pre></div>
<p>The call to <tt class="docutils literal">llvm.memset</tt> is directly followed by a call to <tt class="docutils literal">fread</tt> that may
only partially write the buffer, so there is no way for the compiler to get rid
of it, even if the subsequent <tt class="docutils literal">fwrite</tt> will never access uninitialized slots.</p>
<p>An important point is that on that particular code,
<tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init=zero/default</span></tt> doesn't have any other impact on the
code. In particular no memory read or write is being instrumented.</p>
<p>On the opposite, using <tt class="docutils literal"><span class="pre">-fsanitize=memory</span></tt> leads to the following function
prologue, that contains both a <tt class="docutils literal">memset</tt> of the whole buffer and the <em>xoring</em> of
every loaded address with 87960930222080 (actually <tt class="docutils literal">0x500000000000</tt>). So it's
strictly slower, especially as it impacts elements of the inner loop (whenever
<tt class="docutils literal">stdout</tt> and <tt class="docutils literal">stdin</tt> are loaded in memory.</p>
<div class="highlight"><pre><span></span><span class="w">  </span><span class="nv">%buffer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="p">[</span><span class="m">2048</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">],</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.lifetime.start.p0</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="m">2048</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">)</span><span class="w"> </span><span class="vg">#5</span>
<span class="w">  </span><span class="nv nv-Anonymous">%0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">ptrtoint</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv">%buffer</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">i64</span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">xor</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv nv-Anonymous">%0</span><span class="p">,</span><span class="w"> </span><span class="m">87960930222080</span>
<span class="w">  </span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">inttoptr</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">ptr</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.memset.p0.i64</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="k">dereferenceable</span><span class="p">(</span><span class="m">2048</span><span class="p">)</span><span class="w"> </span><span class="nv nv-Anonymous">%2</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">-1</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">2048</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%_msld</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">inttoptr</span><span class="w"> </span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="k">xor</span><span class="w"> </span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="k">ptrtoint</span><span class="w"> </span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@stdin</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">i64</span><span class="p">),</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">87960930222080</span><span class="p">)</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="kt">ptr</span><span class="p">),</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">8</span>
<span class="w">  </span><span class="nv">%_mscmp17.not</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%_msld</span><span class="p">,</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%_mscmp17.not</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv nv-Anonymous">%4</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv nv-Anonymous">%3</span><span class="p">,</span><span class="w"> </span><span class="nv">!prof</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span>
<span class="nl">3:</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@__msan_warning_noreturn</span><span class="p">()</span><span class="w"> </span><span class="vg">#6</span>
<span class="w">  </span><span class="k">unreachable</span>
<span class="nl">4:</span>
<span class="w">  </span><span class="nv nv-Anonymous">%5</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="kt">ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="vg">@stdin</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="nv">!tbaa</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span>
<span class="w">  </span><span class="nv">%call6</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="vg">@fread</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="nv">%buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="m">2048</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="nv nv-Anonymous">%5</span><span class="p">)</span>
<span class="w">  </span><span class="nv">%cmp7</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">icmp</span><span class="w"> </span><span class="k">eq</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="nv">%call6</span><span class="p">,</span><span class="w"> </span><span class="m">2048</span>
<span class="w">  </span><span class="k">br</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="nv">%cmp7</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while.body</span><span class="p">,</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv">%while.end</span>
</pre></div>
<div class="section" id="compiler-optimization">
<h3>Compiler Optimization</h3>
<p>The astute reader would have noticed that in the original C code, there were two
stack variables: <tt class="docutils literal">buffer</tt> and <tt class="docutils literal">n</tt>. Looking at the output of clang without
optimization, we can see both being allocated <strong>and</strong> initialized in the
function prologue</p>
<div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="p">[</span><span class="m">2048</span><span class="w"> </span><span class="k">x</span><span class="w"> </span><span class="kt">i8</span><span class="p">],</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span>
<span class="nv nv-Anonymous">%3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="kt">i64</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">8</span>
<span class="k">store</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">4</span>
<span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.memset.p0.i64</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">16</span><span class="w"> </span><span class="nv nv-Anonymous">%2</span><span class="p">,</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">-86</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">2048</span><span class="p">,</span><span class="w"> </span><span class="kt">i1</span><span class="w"> </span><span class="k">false</span><span class="p">),</span><span class="w"> </span><span class="nv">!annotation</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span>
<span class="k">store</span><span class="w"> </span><span class="kt">i64</span><span class="w"> </span><span class="m">-6148914691236517206</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv nv-Anonymous">%3</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="nv">!annotation</span><span class="w"> </span><span class="nv nv-Anonymous">!4</span>
<span class="k">br</span><span class="w"> </span><span class="kt">label</span><span class="w"> </span><span class="nv nv-Anonymous">%4</span>
</pre></div>
<p>The <tt class="docutils literal">store</tt> is being optimized out by the compiler (thanks to a following
<tt class="docutils literal">write</tt>) to save the result of <tt class="docutils literal">fread</tt>. That's great news! It means that the
front-end compiler (here Clang) can generate initialization for every stack
variable, and let the optimizer (here LLVM) get rid of the redundant initialization.</p>
</div>
<div class="section" id="lowering">
<h3>Lowering</h3>
<p>When generating assembly code from the LLVM IR, the compiler faces a lot
choices, one of which being «should I turn a call to <tt class="docutils literal">llvm.memset</tt> into a
block of instructions, or into a call to libc's <tt class="docutils literal">memset</tt>?». For large buffer
it chooses the latter, but were the buffer smaller, a bunch of <tt class="docutils literal">mov</tt> (or
<tt class="docutils literal">movaps</tt>, you get the idea) would be generated instead.</p>
</div>
</div>
<div class="section" id="evaluating-using-ftrivial-auto-var-init-xxxx-on-firefox">
<h2>Evaluating Using <tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init=xxxx</span></tt> on Firefox</h2>
<p>As a security-improving flag, <tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init=xxxx</span></tt> has been
considered as a default flag to build Firefox. But as noted above, it (may) have
an impact on runtime performance. In here, we will focus on the impact on
shippable Firefox Linux when running the <a class="reference external" href="https://github.com/WebKit/Speedometer">Speedometer3 benchmark</a>.</p>
<p>Following table summarizes the result we get with the three setups, on three
different desktop targets (actual details are available
<a class="reference external" href="https://treeherder.mozilla.org/perfherder/compare?originalProject=try&amp;originalRevision=72364426229394f8b7818f4e690af89c7004989e&amp;newProject=try&amp;newRevision=7c8edf2bf86ee0df8fa7107dd937d5de5f0f823b&amp;page=1&amp;framework=13">for the pattern setting</a>
and
<a class="reference external" href="https://treeherder.mozilla.org/perfherder/compare?originalProject=try&amp;originalRevision=72364426229394f8b7818f4e690af89c7004989e&amp;newProject=try&amp;newRevision=73a082680aeccbe3f7d5bf7a12c62f522e794254&amp;page=1&amp;framework=13">for the zero setting</a>.</p>
<table border="1" class="docutils">
<caption>Speedometer3 results dependeing on <cite>-ftrivial-auto-var-init</cite>   setting</caption>
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">platform</th>
<th class="head">default</th>
<th class="head">pattern</th>
<th class="head">zero</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>linux64</td>
<td>8.97</td>
<td>8.82</td>
<td>8.87</td>
</tr>
<tr><td>osx10-64</td>
<td>12.05</td>
<td>11.95</td>
<td>12.01</td>
</tr>
<tr><td>win10-64</td>
<td>12.64</td>
<td>12.46</td>
<td>12.47</td>
</tr>
</tbody>
</table>
<p>A 1% regression on performance is not a trade off we are ready to make anytime
soon. Can we do better?</p>
<div class="section" id="spotting-the-culprit">
<h3>Spotting the culprit</h3>
<p>LLVM has a reporting mechanism that helps tracking down the behavior of the
optimizer. In particular, it can report any instruction that ends up with an
<tt class="docutils literal"><span class="pre">!{!&quot;auto-init&quot;}</span></tt> annotation at the end of the optimization pipeline, using
the <tt class="docutils literal"><span class="pre">-Rpass-missed=annotation-remarks</span></tt> flag. On our toy example from the first
section, we get:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>clang<span class="w"> </span>cat.c<span class="w"> </span>-O2<span class="w"> </span>-S<span class="w"> </span>-o-<span class="w"> </span>-ftrivial-auto-var-init<span class="o">=</span>zero<span class="w"> </span>-Rpass-missed<span class="o">=</span>annotation-remarks
cat.c:4:8:<span class="w"> </span>remark:<span class="w"> </span>Call<span class="w"> </span>to<span class="w"> </span>memset<span class="w"> </span>inserted<span class="w"> </span>by<span class="w"> </span>-ftrivial-auto-var-init.<span class="w"> </span>Memory<span class="w"> </span>operation<span class="w"> </span>size:<span class="w"> </span><span class="m">2048</span><span class="w"> </span>bytes.
<span class="w"> </span>Written<span class="w"> </span>Variables:<span class="w"> </span>&lt;unknown&gt;<span class="w"> </span><span class="o">(</span><span class="m">2048</span><span class="w"> </span>bytes<span class="o">)</span>.<span class="w"> </span><span class="o">[</span>-Rpass-missed<span class="o">=</span>annotation-remarks<span class="o">]</span>
</pre></div>
<p>That's pretty nice to spot inserted instructions that end up not being
optimized, but as one can expect from a codebase as large as Firefox's, it
generates too much information.</p>
<p>Fortunately we can combine this with profile information, through
<tt class="docutils literal"><span class="pre">-fdiagnostics-hotness-threshold=auto</span></tt>, to sort out the most impactful
insertion, and analyze the result.</p>
<p>So the methodology becomes:</p>
<ol class="arabic simple">
<li>Compile Firefox with <tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init=zero</span></tt> and <tt class="docutils literal"><span class="pre">-fprofile-generate</span></tt>.</li>
<li>Train Firefox on Speedometer3 to gather profile information.</li>
<li>Recompile Firefox with <tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init=zero</span></tt>, <tt class="docutils literal"><span class="pre">-fprofile-use</span></tt>,
<tt class="docutils literal"><span class="pre">-Rpass-missed=annotation-remarks</span></tt> and <tt class="docutils literal"><span class="pre">-fdiagnostics-hotness-threshold=auto</span></tt>, logging the result.</li>
<li>Do something smart (?) with the result.</li>
</ol>
<p>Applied to our toy program, this summarizes into:</p>
<div class="highlight"><pre><span></span>$<span class="w"> </span>clang<span class="w"> </span>cat.c<span class="w"> </span>-O2<span class="w"> </span>-o<span class="w"> </span>cat.generate<span class="w"> </span>-ftrivial-auto-var-init<span class="o">=</span>zero<span class="w"> </span>-fprofile-generate
$<span class="w"> </span>./cat.generate<span class="w"> </span>&lt;<span class="w"> </span>cat.c
$<span class="w"> </span>llvm-profdata<span class="w"> </span>merge<span class="w"> </span>*.profraw<span class="w"> </span>-o<span class="w"> </span>merged.profdata
$<span class="w"> </span>clang<span class="w"> </span>cat.c<span class="w"> </span>-O2<span class="w"> </span>-o<span class="w"> </span>cat.generate<span class="w"> </span>-ftrivial-auto-var-init<span class="o">=</span>zero<span class="w"> </span>-fprofile-use<span class="o">=</span>merged.profdata<span class="w"> </span>-Rpass-missed<span class="o">=</span>annotation-remarks<span class="w"> </span>-fdiagnostics-hotness-threshold<span class="o">=</span>auto
cat.c:4:8:<span class="w"> </span>remark:<span class="w"> </span>Call<span class="w"> </span>to<span class="w"> </span>memset<span class="w"> </span>inserted<span class="w"> </span>by<span class="w"> </span>-ftrivial-auto-var-init.<span class="w"> </span>Memory<span class="w"> </span>operation<span class="w"> </span>size:<span class="w"> </span><span class="m">2048</span><span class="w"> </span>bytes.
<span class="w"> </span>Written<span class="w"> </span>Variables:<span class="w"> </span>&lt;unknown&gt;<span class="w"> </span><span class="o">(</span><span class="m">2048</span><span class="w"> </span>bytes<span class="o">)</span>.<span class="w"> </span><span class="o">(</span>hotness:<span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="w"> </span><span class="o">[</span>-Rpass-missed<span class="o">=</span>annotation-remarks<span class="o">]</span>
<span class="w">     </span><span class="m">4</span><span class="w"> </span><span class="p">|</span><span class="w">   </span>char<span class="w"> </span>buffer<span class="o">[</span><span class="m">2048</span><span class="o">]</span><span class="p">;</span>
<span class="w">       </span><span class="p">|</span><span class="w">        </span>^
</pre></div>
<p>When applying the above to Firefox, we spotted a few recurring situation I'm
going to cover in the following section.</p>
</div>
</div>
<div class="section" id="recurring-nightmare">
<h2>Recurring Nightmare</h2>
<p><em>Bonus point if you get the reference to the MTG emblematic card.</em></p>
<div class="section" id="smallvector-and-friends">
<h3>SmallVector and Friends</h3>
<p>It is a common optimization to provide data types that preallocates some memory,
aiming at stack allocation, and switching to heap allocation depending on the
usage. In the LLVM codebase those are <tt class="docutils literal">SmallVector</tt>, <tt class="docutils literal">SmallString</tt>, <tt class="docutils literal">SmallPtrSet</tt> etc. Similar performance-oriented data structures can be found in the Firefox codebase in the form of <tt class="docutils literal">nsAutoCString</tt> or <tt class="docutils literal">AutoTArray</tt>. These data types provide an interesting challenge wrt. trivial auto var init: they typically are performance oriented data structure whose buffer is <em>not</em> going to be used right away. It is very unlikely that the compiler can optimize out the initialization of this buffer! Consider the following:</p>
<div class="highlight"><pre><span></span><span class="c1">// copy a C string into a nsAutoCStringN</span>
<span class="n">nsAutoCStringN</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span><span class="w"> </span><span class="n">line</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</pre></div>
<p>Depending on the <em>runtime</em> size of <tt class="docutils literal">buffer</tt>, the pre-allocated buffer of
<tt class="docutils literal">line</tt> is going to be either partially filled, totally filled or unused in
favor of stack allocation. Only in the second case is it valid to get rid of the
full initialization... And there is no way the compiler could handle that
statically.</p>
<p>In some cases it is possible to avoid using these data structures (see <a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1850948">Bug
1850948</a>)</p>
</div>
<div class="section" id="initialization-within-a-loop">
<h3>Initialization within a Loop</h3>
<p>It is quite common to declare stack variables to the stricter scope needed. It
improves locality (from a code review point of view) and it avoids exposing
variable content to other code portion. However, the interaction with
<tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init</span></tt> is not negligible. Consider the following code that
reads info from <tt class="docutils literal">/proc/self/maps</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[...]</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">modulePath</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span>
<span class="w">                 </span><span class="s">&quot;%lx-%lx %6s %lx %*s %*x %&quot;</span><span class="w"> </span><span class="n">PATH_MAX_STRING</span><span class="p">(</span><span class="n">PATH_MAX</span><span class="p">)</span>
<span class="w">                 </span><span class="s">&quot;s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                 </span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">perm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">modulePath</span><span class="p">);</span>
<span class="w">  </span><span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init</span></tt> has the (expected!) effect of adding a <tt class="docutils literal">memset</tt> inside
the loop, to initialize <tt class="docutils literal">modulePath</tt>. The allocation itself is going to be moved
in the function prologue, but not the initialisation. This turns a
<span class="formula"><span class="scriptfont">O</span>(1)</span> instruction into a <span class="formula"><span class="scriptfont">O</span>(<i>n</i>×<i>m</i>)</span> one, where <span class="formula"><i>n</i></span> is
the size of the buffer and <span class="formula"><i>m</i></span> is the number of loop iteration. Not ideal.</p>
<p>The trivial (but manual) fix here is to rewrite the code as follow:</p>
<div class="highlight"><pre><span></span><span class="kt">char</span><span class="w"> </span><span class="n">modulePath</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">[...]</span>
<span class="w">  </span><span class="n">modulePath</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sscanf</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span>
<span class="w">                 </span><span class="s">&quot;%lx-%lx %6s %lx %*s %*x %&quot;</span><span class="w"> </span><span class="n">PATH_MAX_STRING</span><span class="p">(</span><span class="n">PATH_MAX</span><span class="p">)</span>
<span class="w">                 </span><span class="s">&quot;s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
<span class="w">                 </span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">perm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">modulePath</span><span class="p">);</span>
<span class="w">  </span><span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
<p>This is not strictly equivalent though: if the loop is never entered, we still
pay for one initialisation, and the <span class="formula"><i>k</i><sup><span class="text">th</span></sup></span> iteration can <em>see</em> the
content of previous iteration's buffer. We applied a similar patch for <a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1850951">Bug
1850951</a></p>
</div>
<div class="section" id="empty-class">
<h3>Empty Class</h3>
<p>Every object that may have its address taken must have a size of at least one
byte. Even if it doesn't have any members. That would be the case of the
following class:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Holder</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Holder</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;enter&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">Holder</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;exit&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">log</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Holder</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">    </span><span class="n">h</span><span class="p">.</span><span class="n">log</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<p>Now let's imagine the compiler doesn't have access to <tt class="docutils literal"><span class="pre">Holder::log()</span></tt>
implementation. Or maybe it has access to it but it cannot inline it. Because it
is a member function, it takes an (implicit) reference to <tt class="docutils literal">this</tt> as first
parameter. So the address of the object is taken. So its size becomes one, and
<tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init</span></tt> makes sure this padding byte is
initialized. After all, that's stack memory! Here is the LLVM bitcode output by
the compiler from the above snippet after <tt class="docutils literal">clang++ <span class="pre">-S</span> <span class="pre">-emit-llvm</span> <span class="pre">-O2</span>
<span class="pre">-ftrivial-auto-var-init=pattern</span> <span class="pre">-o-</span> a.cpp <span class="pre">-fno-exceptions</span></tt> (passing
<tt class="docutils literal"><span class="pre">-fno-exceptions</span></tt> just to avoid the extra clutter). We can see the extra
<tt class="docutils literal">store i8 <span class="pre">-86,</span> ptr %1, align 1, !annotation !3</tt> that's not wanted, and the
<tt class="docutils literal">ptr noundef nonnull align 1 dereferenceable(1) %1</tt> as first parameter of
<tt class="docutils literal">call void &#64;_ZNK6Holder3logEv</tt>, i.e. <tt class="docutils literal">void <span class="pre">&#64;Holder::log()</span> const</tt>.</p>
<div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@_Z3foov</span><span class="p">()</span><span class="w"> </span><span class="k">local_unnamed_addr</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">alloca</span><span class="w"> </span><span class="nv">%struct.Holder</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">1</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.lifetime.start.p0</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">)</span><span class="w"> </span><span class="vg">#4</span>
<span class="w">  </span><span class="k">store</span><span class="w"> </span><span class="kt">i8</span><span class="w"> </span><span class="m">-86</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">,</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="nv">!annotation</span><span class="w"> </span><span class="nv nv-Anonymous">!3</span>
<span class="w">  </span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@puts</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="vg">@.str</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@_ZNK6Holder3logEv</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="k">align</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">)</span><span class="w"> </span><span class="vg">#4</span>
<span class="w">  </span><span class="nv nv-Anonymous">%3</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@puts</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="vg">@.str.1</span><span class="p">)</span>
<span class="w">  </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@llvm.lifetime.end.p0</span><span class="p">(</span><span class="kt">i64</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="kt">ptr</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="nv nv-Anonymous">%1</span><span class="p">)</span><span class="w"> </span><span class="vg">#4</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
<span class="p">}</span>
</pre></div>
<p>Can we help the compiler there? Actually we can, by informing it that <tt class="docutils literal"><span class="pre">Holder::log</span></tt> doesn't need any reference to <tt class="docutils literal">this</tt>, while preventing it to be called without object attached:</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Holder</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Holder</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;enter&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="o">~</span><span class="n">Holder</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">puts</span><span class="p">(</span><span class="s">&quot;exit&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">log</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">log_impl</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">log_impl</span><span class="p">();</span>
<span class="p">};</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Holder</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">    </span><span class="n">h</span><span class="p">.</span><span class="n">log</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<p>gets compiled into the expected:</p>
<div class="highlight"><pre><span></span><span class="k">define</span><span class="w"> </span><span class="k">dso_local</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@_Z3foov</span><span class="p">()</span><span class="w"> </span><span class="k">local_unnamed_addr</span><span class="w"> </span><span class="vg">#0</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv nv-Anonymous">%1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@puts</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="vg">@.str</span><span class="p">)</span>
<span class="w">  </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="vg">@_ZN6Holder8log_implEv</span><span class="p">()</span><span class="w"> </span><span class="vg">#3</span>
<span class="w">  </span><span class="nv nv-Anonymous">%2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">tail</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@puts</span><span class="p">(</span><span class="kt">ptr</span><span class="w"> </span><span class="k">noundef</span><span class="w"> </span><span class="k">nonnull</span><span class="w"> </span><span class="k">dereferenceable</span><span class="p">(</span><span class="m">1</span><span class="p">)</span><span class="w"> </span><span class="vg">@.str.1</span><span class="p">)</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="k">void</span>
</pre></div>
<p>This approach has been used in <a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1844520">Bug 1844520</a>.</p>
</div>
<div class="section" id="manual-check">
<h3>Manual Check</h3>
<p>At some point in the process, I decided to flag the top 100 variables reported
as initialized and hot with the attribute <tt class="docutils literal"><span class="pre">__attribute__((uninitialized))</span></tt>,
which has the effect of preventing any extra initialization code to be inserted
by <tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init</span></tt>. I was very hopeful with that approach, as I
was expecting this attribute to significantly decrease the impact of auto-initialization on performance.
Unfortunately the opposite happened:
almost no speed improvement. This tells us that the performance impact is not
due to a few hotspot but spread across the whole codebase. So the whole idea of
handling every situation one after the other is unlikely to be enough! How
depressing.</p>
<p>Let's still have a look at a final situation.</p>
</div>
<div class="section" id="value-semantic">
<h3>Value Semantic</h3>
<p>Maybe as an inheritance of C, maybe as an inheritance of C++98, we often see
interfaces that use pass-by-reference as a way to return extra values. For
instance in the following code <tt class="docutils literal">doStuff</tt> returns <tt class="docutils literal">false</tt> in case of error,
and <tt class="docutils literal">true</tt> and sets <tt class="docutils literal">result</tt> in case of success.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;cstdio&gt;</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">doStuff</span><span class="p">(</span><span class="kt">char</span><span class="o">*&amp;</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">doStuff</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
<span class="w">    </span><span class="n">puts</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>From the compiler point of view, there is no guarantee that <tt class="docutils literal">res</tt> has been
initialized with <tt class="docutils literal">doStuff</tt>. And doing so would mean being able to couple value
and control-flow, something compilers are not always very good at.</p>
<p>I've asked myself how we could <em>inform</em> the compiler about this behavior. It
turns out LLVM does have attribute to specify interaction of parameters wrt.
memory, through <tt class="docutils literal"><span class="pre">memory(...)</span></tt>. For instance, according to the <a class="reference external" href="https://llvm.org/docs/LangRef.html">language
reference</a> one can use <tt class="docutils literal">memory(argmem:
read, inaccessiblemem: write)</tt> to specify that</p>
<blockquote>
May only read argument memory and only write inaccessible memory.</blockquote>
<p>But there is no way to state that the function <strong>must</strong> write to the location.
And even with that piece of information, we would have to state the write is
only done if the return value is <tt class="docutils literal">true</tt>.</p>
<p>One option though would be to return an <tt class="docutils literal"><span class="pre">std::optional</span></tt>. In that case the
problem of initializing the return value is deferred to <tt class="docutils literal"><span class="pre">std::optional</span></tt>. In
turn <tt class="docutils literal"><span class="pre">std::optional</span></tt> needs to initialize its inner members, so we're only
moving the problem.</p>
<p>This is, however, quite close to the situation we had with data structures that
preallocate memory: no normal usage of the data structure should lead to an
access of the uninitialized memory, and those data structures are critical
enough to trade security for performance. What about flagging them with a
specific attribute that would bypass the trivial initialization mechanism? I
actually <a class="reference external" href="https://reviews.llvm.org/D156337">submitted a patch</a> to implement
that, only to realize that the right approach would be to allow setting the
attribute on class members, which turns out to be trickier than expected. But if
we could do this, we would impact the whole codebase by only adding a few
attributes, which is much more rewarding than mechanically tracking hotspots.</p>
</div>
<div class="section" id="concluding-words">
<h3>Concluding Words</h3>
<p>So in the end, tehre was no straight-forward fix to prevent the performance
regression caused by <tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init</span></tt>, and Firefox is probably not
going to move there anytime soon. How disappointing?</p>
<p>But let's be positive! In the process of trying to decrease the performance impact
of <tt class="docutils literal"><span class="pre">-ftrivial-auto-var-init</span></tt> on Firefox codebase, I grabbed a better understanding
of the original problem and how clang approaches it. I also came up with a methodology
to track the performance impact and iteratively improve the situation. And I
shared that knowledge with you, and there is value in it, isn't there?</p>
<div class="section" id="acknowledgments">
<h4>Acknowledgments</h4>
<p>The author would like to thank Frederik Braun, Tom Ritter and Sylvestre Ledru
for the proofreading of this post and the fruitful discussion we've been having
on that topic.</p>
</div>
</div>
</div>

    </article>
    <section class="post-nav">
        <div id="left-page">
            <div id="left-link">
            </div>
        </div>
        <div id="right-page">
            <div id="right-link">
            </div>
        </div>
    </section>
    <div>
    </div>
</main>
    <footer>
        <h6>
            Rendered by <a href="http://getpelican.com/">Pelican</a> &nbsp;&bull;&nbsp; Theme by <a
                href="https://github.com/aleylara/Peli-Kiera">Peli-Kiera</a> &nbsp;&bull;&nbsp; Copyright
                &copy &nbsp;&#8209;&nbsp; serge-sans-paille and other pythraners         </h6>
    </footer>
</div>
</body>
</html>
